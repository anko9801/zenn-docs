---
title: "【CTF 探訪記】Heap Exploit"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn"]
published: true
---

ヒープ領域を攻撃してみる話。ここでは 64bit システムを前提とします。

## malloc / free の仕組み

`malloc()` でヒープ領域にあるメモリを確保してそのポインタを返し、`free()` はそのポインタのメモリを開放してくれます。

```c
void *malloc(size_t size);
void free(void *ptr);
```
このヒープ領域のインターフェースである malloc / free 関数の処理を理解するのが Heap Exploit の大事な大きな一歩となります。

とりあえずこの伝説の malloc 動画を見ましょう。

https://www.youtube.com/watch?v=0-vWT-t0UHg

あと malloc.c の読書は次の記事にまとめました。それぞれ大分短くまとまったので先に読んでもらいたいです。

- [malloc.c を読む (malloc / free)](https://zenn.dev/anko/articles/malloc-malloc-free)
- [malloc.c を読む (bins)](https://zenn.dev/anko/articles/malloc-each-bins)
- [malloc.c を読む (arena)](https://zenn.dev/anko/articles/malloc-arena)

## おおざっぱな理解

ヒープ領域ではチャンクと呼ばれる構造体が大量にあり、それぞれ使われているチャンクだったり、解放されたチャンクだったりします。`malloc` すると解放されたチャンクの中からチャンクが切り出され、そのデータ部分へのポインタが返されます。逆に `free` すると解放された旨のメタ情報をチャンクに書き込み、free list に繋げます。

具体的にはチャンクは次のような構造となっています。

- チャンクのサイズは 0x20 バイト以上で 0x10 の倍数となっている。
- 確保したデータの直前にチャンクサイズなどのメタデータが書き込まれており、データの末尾 8 バイトは次のチャンクと被っている。

![](/images/pwn/chunk.png =480x)

| フィールド名 | 説明 |
| :-: | --- |
| prev_size | 一つ前のチャンクのサイズ。PREV_INUSE フラグが立っていないときに書き込まれている。 |
| size | このチャンクのサイズ。下位 3bit はフラグとして使われる。 |
| NON_MAIN_ARENA | チャンクを管理しているのが `main_arena` であるかどうか (ヒープ領域の管理部にアクセスする際に必要) |
| IS_MMAPED | メモリが mmap で確保されたか (free 時の munmap で解放するかの判断に必要) |
| PREV_INUSE | 前のチャンクが使用中か。使用中でなければ prev_size に前のチャンクサイズが書き込まれている。 |

また `free` するときに高速に処理するために解放されたチャンクの一覧 free list を管理しています。

この free list が Heap Exploit の中で重要なので次ではこの構造と具体的な動作を解説していきます。

## チャンクの管理

free list の正体は bins と呼ばれるリスト群です。bins はいくつかの種類があってサイズによって管理の仕方を変えることで最適化しています。

| bins の種類 | サイズ | 説明 | データ構造 |
| --- | --- | --- | --- |
| tcache bins | 0x20 ~ 0x410 | 最初に入れられる just-fit な bin | 単方向リスト |
| fastbins | 0x20 ~ 0x80 | tcache が満杯になったら入れられる just-fit な bin | 単方向リスト |
| unsortedbin | 0x20 ~ | 最近アクセスしたチャンクが入れられる bin | 双方向リスト |
| smallbins | 0x20 ~ 0x3f0 | unsortedbin から来る小さなチャンクを管理する just-fit な bin | 双方向リスト |
| largebins | 0x400 ~ | unsortedbin から来る大きなチャンクを管理する bin | 双方向リスト + スキップリスト |

データ構造は 2 つあり、それぞれの挿入 (link) や削除 (unlink) の処理は理解している前提で話を進めます。

- 単方向リストは単方向にしか移動できない繋ぎ変えが簡単な高速なリストです。LIFO で先頭は arena で管理されています。チャンクのデータ部分の先頭 8 バイトは forward pointer (fd) として使われ、次のチャンクのポインターが格納されています。末尾の fd は NULL になります。
- 双方向リストは双方向移動できる円形のリストです。FIFO で先頭と末尾は arena で管理されていて、チャンクのデータ部分の先頭 16 バイトは forward pointer (fd), back pointer (bk) として使われます。


### tcache bins

glibc v2.26 以降に追加された bin。参照局所性を高める為に `malloc / free` で一番最初に処理されるのが tcache bins です。tcache bins はチャンクサイズが 0x20 から 0x410 までの 64 種類の tcache bin を持ち、それぞれ単方向リストとなっています。リストの長さは 7 個に制限されていて tcache が満杯になると他の bins に移されます。サイズごとに分けられているので just-fit で返せます。

![](/images/pwn/tcache.png =480x)

tcache bins の実体は `tcache_perthread_struct` 構造体です。 `entries` で各リストの HEAD のチャンクに繋げて、 `counts` でリストの長さを管理し、7 個になったら受け付けないようにします。チャンクが tcache bin に入るとデータ部分に `tcache_entry` 構造体が overlap されてリストに入ります。

```c
typedef struct tcache_entry
{
  struct tcache_entry *next;              // 次の tcache_entry へのポインタ
  struct tcache_perthread_struct *key;    // 乱数を用いて double free を検知
} tcache_entry;

typedef struct tcache_perthread_struct
{
  uint16_t counts[TCACHE_MAX_BINS];       // 各 bin の長さの一覧
  tcache_entry *entries[TCACHE_MAX_BINS]; // 各 bin の最初の tcache へのポインタの一覧
} tcache_perthread_struct;
```


### fastbins

glibc v2.3 からある小さなチャンクを管理する bin。fastbins はチャンクサイズが 0x20 から 0x80 まで 7 種類の fastbin を持ち、小さなチャンクは頻繁に確保・開放が起きやすいのでそれぞれ単方向リストとなっています。

![](/images/pwn/fastbin.png =480x)

```c
struct malloc_state
{
    ...
    int have_fastchunks;
    mfastbinptr fastbinsY[NFASTBINS];
    ...
};
```


### unsortedbin

tcache や fastbins のおこぼれや fastbins の consolidation されたチャンクを unsortedbin が管理します。unsortedbin は 1 つの双方向リストとなっています。unsortedbin でソートが起こると smallbins か largebins に繋がれます。

![](/images/pwn/smallbin.png =480x)

unsortedbin の先頭・末尾は `bin_at(1)` つまり `arena` の `bins[0]` と `bins[1]` に格納され、unsortedbin の末尾チャンクの `fd` は `main_arena.top` を指します。


### smallbins

unsortedbin に入れたチャンクで小さいチャンクは smallbins に繋がれます。smallbins はチャンクサイズが 0x20 から 0x3f0 まで 62 種類の smallbin を持ち、それぞれ双方向リストとなっています。

![](/images/pwn/smallbin.png =480x)

smallbins の先頭・末尾は `bin_at(2)` から `bin_at(63)` までに格納されています。

```c
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > CHUNK_HDR_SZ)

#define smallbin_index(sz) \
  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3))\
   + SMALLBIN_CORRECTION)
```

### largebins

大きなサイズのチャンクも 16 バイトごとに管理するのは現実的ではありません。チャンクサイズが大きくなるにつれて幅も指数的に大きくすることでリストの数を平均化し、最悪計算量を減らすことができます。largebins はチャンクサイズが 0x400 ~ 0x430, 0x440 ~ 0x470, …, 0x1000000 ~ 0x1fffff0, 0x2000000 ~ の 63 種類の largebin を持ち、それぞれサイズに応じて順序立てた双方向リストとなっています。これは双方向リストのメンバに加えて `fd_nextsize` `bk_nextsize` があり、それぞれチャンクの幅の中で次に大きなチャンクと次に小さなチャンクへのポインタが格納されます。

![](/images/pwn/largebin.png =480x)

largebins の先頭・末尾は `bin_at(64)` から `bin_at(126)` までに格納されます。
largebins から確保されたメモリは `last_remainder` はセットされません。

```c
#define largebin_index_64(sz)                                                \
  (((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\
   ((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
   ((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
   ((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
   ((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
   126)

#define largebin_index(sz) \
  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
   : largebin_index_32 (sz))
```

## グローバル領域
### main_arena

これらの bins はアリーナという機構によって管理されます。アリーナは単方向リストでスレッドごとに先頭を `main_arena` という変数に格納されています。

アリーナは `malloc_state` 構造体で定義されています。

```c
struct malloc_state
{
  __libc_lock_define (, mutex);     // arena へのアクセスを serialize する
  int flags;                        // ヒープメモリが連続であるか

  int have_fastchunks;              // fastbins が空ではないことを表す真偽値
  mfastbinptr fastbinsY[NFASTBINS]; // fastbins

  mchunkptr top;                    // ヒープ領域の最後にある未使用の大きなチャンク
  mchunkptr last_remainder;         // 分割して確保した際に余った領域の最新のチャンク

  mchunkptr bins[NBINS * 2 - 2];    // unsortedbin smallbins largebins の先頭・末尾
  unsigned int binmap[BINMAPSIZE];  // これらを素早く見つける為に使われるビットベクタ

  struct malloc_state *next;        // arena の単方向リスト
  struct malloc_state *next_free;   // 使われていない arena の単方向リスト
  INTERNAL_SIZE_T attached_threads; // arena にアクセスしているスレッドの数

  INTERNAL_SIZE_T system_mem;       // arena によって現在確保されているメモリの合計値
  INTERNAL_SIZE_T max_system_mem;   // system_mem の最大値
};
```

### malloc hooks

glibc にはいくつかの hook がありますが malloc 関連の hooks は Heap Exploit にて非常によく使われていました。

| 関数名 | 条件 |
| --- | --- |
| `__malloc_hook` | `malloc()` 呼び出し時 |
| `__free_hook` | `free()` 呼び出し時 |
| `__realloc_hook` | `realloc()` 呼び出し時 |
| `__after_morecore_hook` | `malloc()` 呼び出し時 |
| `__malloc_initialize_hook` | 初期 `malloc()` 時 |
| `__memalign_hook` | `aligned_alloc()` `memalign()` `posix_memalign()` `valloc()` 呼び出し時 |
| `_dl_open_hook` | 共有ライブラリファイルのロード時 |

しかしこれらの hooks は glibc v2.34 以降で削除されました。

## ヒープ領域での書き換え

ヒープ領域においては `fd` `bk` の書き換えが目標です。これができれば free list のリスト構造を壊すことができます。これによって malloc / free を繰り返すとそのアドレスへ書き換えが出来るようになります。

### Use After Free
free 関数が呼ばれた後でも読み書きが出来てしまう脆弱性。これが一番手っ取り早く `fd` `bk` の読み書きが出来ます。

解放されたメモリへのポインタを dangling pointer (ぶらさがったポインタ) と言います。

### Heap based Buffer Overflow
Heap 上での BOF です。複数回 malloc すると参照居所性などの理由から連続に並ぶことが多いです。そうすると使われているチャンクから BOF して別のチャンクの書き換えができるようになり、変数の書き換えや `fd` `bk` の書き換えが出来ます。

### double free

Use After Free や HBOF が出来なくとも double free させればリストがループするから適切に malloc した領域でも fd に意図したアドレスを書き込めるようになる。

glibc 2.28 以前の tcache では double free が検出されませんが、glibc 2.29 以降では `key` という `tcache_perthread_struct` 構造体を指すフィールドが追加され、double free 検査が入るようになった。

## ヒープ領域での攻撃方法
ヒープ領域では大量の攻撃手法が見つかっています。これらはそれぞれ独自性があるものの共通する部分が数多くあるので、その手法を細かく分ければパズルのように組み合わせることで多くの手法を理解することができます。

ヒープを壊すことをひたすら考えてまとめてみましょう。


| 条件 | 可能な処理 |
| --- | --- |
| 整合性を満たした `fd` `bk` の書き換え | `free()` で free list に偽チャンク挿入。2 回目以降は `free()` 失敗する |
| 偽チャンクの確保・書き込み | 任意アドレス書き込み |
| unsortedbin の `bk` の書き換え | unlink 時に `bk->fd = bk + 0x10` に `&main_arena.top` が書き込まれる (< 2.28) |
| unsortedbin の `fd` の読み取り | `&main_arena.bins` で libc leak |
| 次のチャンクの `PREV_INUSE` をクリア<br> `fd` `bk` `prev_size` を書き換え | `free()` の consolidation backward で unsortedbin に偽チャンク挿入 |
| `global_max_fast` の書き換え | `free()` で fastbins 以降にアドレスを書き込める |
| `main_arena` で `NON_MAIN_ARENA` を立てる | arena の位置をずらして書き込める |
| top chunk のサイズ以上の `malloc()` | top chunk が `free()` される |
| `arena_key` を書き換える (< 2.4) | |

整合性チェック
| 整合性チェック | バイパス |
| --- | --- |
| fastbins 先頭の double free 検知 | 先頭ではない |
| smallbins `victim.bk->fd == victim` | `fd` `bk` を自分自身に向ける (2.27) |


### tcache poisoning

tcache に入れたチャンクの next を書き換えて malloc することで AAW できる脆弱性。注意するべきは tcache が LIFO なリストな為に malloc free を繰り返さなければならない
tcache poisoning して `__free_hook` を書き換える。
同じ領域に悪意のあるデータ構造を確保して利用させる事で、関数ポインタを書き換える。

[SECCON Beginners CTF 2020 [Beginners Heap] Writeup &初心者向け解説 - Qiita](https://qiita.com/hanya1995/items/c29a89737bbd521e67f2)
[SECCON Beginners CTF 2019 - Babyheap - HackMD](https://hackmd.io/@Xornet/H1hYUUR2I)

### unsortedbin attack
fd に arena.bin が書き込まれる。libc leak
< 2.29

- [Security Fest 2019 - Baby5 (Unsorted Bin) - HackMD](https://hackmd.io/@Xornet/rycqVwQpL)
- [n日1CTFチャレンジ - HackMD](https://hackmd.io/@Xornet/BkemeSAhU)

### House of XXX シリーズ
House of XXX シリーズは glibc malloc で発見された攻撃手法の総称です。2001 年ごろからあるらしいです。
House Of XXX シリーズは大量にあるのでここではリスト形式で紹介します。あとでそれぞれ書き起こしたいと思います。
- https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt
- https://www.slideshare.net/codeblue_jp/cb16-matsukuma-ja-68459648

| 攻撃名 | glibc | アイデア |
| --- | --- | --- |
| House of Prime | < 2.4 | 8 バイトチャンクを `free()` して `fastbinsY[-1] == max_fast` を書き換えて、 `fastbinsY[289] == arena_key` を書き換える |
| House of Corrosion | 2.26 < glibc < 2.30 | `global_max_fast` を書き換え<br> `stderr` を改ざんする |
| House of Mind | < 2.11 | チャンクの `NON_MAIN_ARENA` |
| House of Orange | < 2.26 | top chunk のサイズを縮める `malloc()` を呼ぶと `sysmalloc()` で `_int_free()` が呼び出される  unsortedbin attack  `_IO_list_all` abort() すると _IO_flush_all_lockp() が呼び出される |
| House of Einherjar | | PREV_INUSE の書き換え unlink attack |

## セキュリティ機構のバイパス
### tcache dup
tcache において double-free 検知が起きる。 fastbin で double-free を起こすことでバイパスする。

## glibc のビルド
特定の glibc のバージョンでの攻撃を試したいときにそのバージョンの glibc とバイナリの紐付けが必要になります。

次の URL で必要なバージョンの glibc のソースをダウンロードし、ビルドすると動的ライブラリ (.so) が得られます。(こうするとデバッグ情報も付いてくるので嬉しい)

- http://ftp.gnu.org/gnu/glibc/

```shell
mkdir build; cd build
../glibc-version/congifure --prefix=/path/to/build
make
make install
```

`ldd` コマンドで実行ファイルに紐付いている動的ライブラリを教えてくれます。
`pwninit` コマンドで実行ファイルと動的ライブラリを同じ階層に入れておけば紐付けてくれます。

https://github.com/io12/pwninit

## まとめ
Heap Exploit をまとめました。今回は Linux のみの紹介になりましたが Microsoft の mimalloc とかもあります。
https://qiita.com/methane/items/e88901b7392c10cee2c9

これが出来るようになれば pwn 中級者と言えそうです。

## 参考資料
- https://github.com/shellphish/how2heap
- [Overview of GLIBC heap exploitation techniques](https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/)
- [【LCR 1.1】LibcCodeReading: malloc編[2]=fastbins・smallbins - newbie dive into binary (hatenablog.com)](https://smallkirby.hatenablog.com/entry/2019/09/23/001554)
