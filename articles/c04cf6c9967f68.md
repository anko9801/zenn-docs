---
title: "【CTF 探訪記】Heap Exploit"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn"]
published: true
---

ヒープ領域を攻撃してみる話。ここでは 64bit システムを前提とします。

## malloc / free の仕組み
このヒープ領域のインターフェースである malloc / free 関数の処理を理解するのが Heap Exploit の大事な大きな一歩となります。

とりあえずこの伝説の動画を見て [**最新の malloc.c のソースコード**](https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html) を用意しましょう。

https://www.youtube.com/watch?v=0-vWT-t0UHg

これを元に理解を深めていきます。

## おおざっぱな理解

### 開発者視点

`malloc` 関数でヒープ領域にあるメモリを確保してそのポインタを返す。 `free` 関数はそのポインタのメモリを開放してくれる。

```c
void *malloc(size_t size);
void free(void *ptr);
```

### 低レイヤー視点

ヒープ領域ではチャンクと呼ばれる構造体が大量にあり、それぞれ使われているチャンクだったり、解放されたチャンクだったりします。`malloc` すると解放されたチャンクの中からチャンクが切り出され、`free` するとチャンクに解放されたことを書いておきます。

具体的にチャンクは次のような構造となっています。

- チャンクのサイズは 0x20 以上の 0x10 の倍数となる。
- 確保したデータの直前にチャンクサイズなどのメタデータが書き込まれており、データの末尾 8 バイトは次のチャンクと被っている。
- メタデータの一つ `size` の下位 3bit はフラグとして使われる。
  - `A: non_main_arena`  `main_arena` であるかどうか
  - `M: is_mmaped`  メモリが mmap で確保されたか
  - `P: prev_inuse`  前のチャンクが使用中か。使用中でなければ `prev_size` に前のチャンクサイズが書き込まれている。

![](/images/pwn/chunk.png)

`malloc` で返ってくるポインタがこのチャンク内のデータへのポインタとなります。また `free` するときに高速に処理するために解放されたチャンクの一覧 free list を管理しています。

これに関して用語がよく出てくるのでここでまとめておきます。

| 用語 | 説明 |
| --- | --- |
| Remaindering | 要求のあったサイズと合致するチャンクが見つからない場合、既存のチャンクを要求サイズで分割する場合があります。残りの領域は新たなチャンクとして登録され、その内最新のものはアリーナの `last_remainder` に格納される。 |
| Exhausting | 要求のあったサイズ `N` と合致するチャンクが見つからず、サイズ `N + 0x10` のチャンクがある場合、分割せずにそのまま使うこと。 |
| Consolidation | 解放されたチャンクが隣り合っていたときに 2 つのチャンクを統合すること。これによってフラグメンテーションを防ぐ。 |
| フラグメンテーション | `malloc` `free` を繰り返すことで未使用のチャンクがバラバラになってしまうこと。 |

この free list が Heap Exploit の中で重要なので次ではこの構造と具体的な動作を解説していきます。

## チャンクの管理

free list の正体は bins と呼ばれるリスト群です。bins はいくつかの種類があってサイズによって管理の仕方を変えることで最適化しています。

| bins の種類 | サイズ | 説明 | データ構造 |
| --- | --- | --- | --- |
| tcache bins | 0x20 ~ 0x410 | 最初に入れられる just-fit な bin | 単方向リスト |
| fastbins | 0x20 ~ 0x80 | tcache が満杯になったら入れられる just-fit な bin | 単方向リスト |
| unsortedbin | 0x20 ~ | tcache, fastbins で取り扱えないときや fastbins consolidation で入れられる bin | 双方向リスト |
| smallbins | 0x20 ~ 0x3f0 | unsortedbin から来る小さなチャンクを管理する just-fit な bin | 双方向リスト |
| largebins | 0x400 ~ | unsortedbin から来る大きなチャンクを管理する bin | 双方向リスト + スキップリスト |

データ構造は 2 つあり、それぞれの挿入 (link) や削除 (unlink) の処理は理解している前提で話を進めます。

- 単方向リストは単方向にしか移動できない繋ぎ変えが簡単な高速なリストです。LIFO で先頭は arena で管理されています。チャンクのデータ部分の先頭 8 バイトは forward pointer (fd) として使われ、次のチャンクのポインターが格納されています。末尾の fd は NULL になります。
- 双方向リストは双方向移動できる円形のリストです。FIFO で先頭と末尾は arena で管理されていて、チャンクのデータ部分の先頭 16 バイトは forward pointer (fd), back pointer (bk) として使われます。


### tcache bins

glibc v2.26 以降に追加された bin。参照局所性を高める為に `malloc / free` で一番最初に処理されるのが tcache bins です。tcache bins はチャンクサイズが 0x20 から 0x410 までの 64 種類の tcache bin を持ち、それぞれ単方向リストとなっている。リストの長さは 7 個に制限されていて tcache が満杯になると他の bins に移される。サイズごとに分けられているので just-fit で返せます。

tcache bins の実体は `tcache_perthread_struct` 構造体です。 `entries` で各リストの HEAD のチャンクに繋げて、 `counts` でリストの長さを管理し、7 個になったら受け付けないようにします。チャンクが tcache bin に入るとデータ部分に `tcache_entry` 構造体が overlap されてリストに入ります。

```c
typedef struct tcache_entry
{
 struct tcache_entry *next;              // 次の tcache_entry へのポインタ
 struct tcache_perthread_struct *key;    // 親の tcache_perthread_struct を指し double free を検知する。
} tcache_entry;

typedef struct tcache_perthread_struct
{
 uint16_t counts[TCACHE_MAX_BINS];       // 各 tcache bin の長さの一覧
 tcache_entry *entries[TCACHE_MAX_BINS]; // 各 tcache bin の最初の tcache へのポインタの一覧
} tcache_perthread_struct;
```

![](/images/pwn/tcache.png)

### fastbins

glibc v2.3 からある小さなチャンクを管理する bin。fastbins はチャンクサイズが 0x20 から 0x80 まで 7 種類の fastbin を持ち、小さなチャンクは頻繁に確保・開放が起きやすいのでそれぞれ単方向リストとなっている。

fastbins の実体は `arena` にある `fastbinsY` です。`NFASTBINS == 10` かつ `global_max_fast == 0x80`

```c
struct malloc_state
{
  ...
  int have_fastchunks;
  mfastbinptr fastbinsY[NFASTBINS];
  ...
};
```

![](/images/pwn/fastbin.png)

### unsortedbin

tcache や fastbins のおこぼれや fastbins の consolidation されたチャンクを unsortedbin が管理します。unsortedbin は 1 つの双方向リストとなっています。unsortedbin でソートが起こると smallbins か largebins に繋がれる。

unsortedbin の先頭・末尾は `bin_at(1)` つまり `arena` の `bins[0]` と `bins[1]` に格納されています。

unsortedbin の `fd` は `main_arena.top` を指す。

```c
/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */
#define unsorted_chunks(M)          (bin_at (M, 1))
```

### smallbins

unsortedbin に入れたチャンクで小さいチャンクは smallbins に繋がれます。smallbins はチャンクサイズが 0x20 から 0x3f0 まで 62 種類の smallbin を持ち、それぞれ双方向リストとなっている。

smallbins の先頭・末尾は `bin_at(2)` から `bin_at(63)` までに格納されています。

```c
#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > CHUNK_HDR_SZ)

#define smallbin_index(sz) \
  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3))\
   + SMALLBIN_CORRECTION)
```

![](/images/pwn/smallbin.png)

### largebins

大きなサイズのチャンクも 16 バイトごとに管理するのは現実的ではない。チャンクサイズが大きくなるにつれて幅も指数的に大きくすることでリストの数を平均化し、最悪計算量を減らす。largebins はチャンクサイズが 0x400 ~ 0x430, 0x440 ~ 0x470, …, 0x1000000 ~ 0x1fffff0, 0x2000000 ~ の 63 種類の largebin を持ち、それぞれサイズに応じて順序立てた双方向リストとなっている。これは双方向リストのメンバに加えて `fd_nextsize` `bk_nextsize` があり、それぞれチャンクの幅の中で次に大きなチャンクと次に小さなチャンクへのポインタが格納される。

largebins の先頭・末尾は `bin_at(64)` から `bin_at(126)` までに格納される。

largebins から確保されたメモリは `last_remainder` はセットされない。

```c
#define largebin_index_64(sz)                                                \
  (((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\
   ((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\
   ((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\
   ((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\
   ((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\
   126)

#define largebin_index(sz) \
  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
   : largebin_index_32 (sz))
```

![](/images/pwn/largebin.png)

## アリーナ

これらの bins はアリーナという機構によって管理されます。アリーナは単方向リストでスレッドごとに先頭を `main_arena` という変数に格納されている。

アリーナは `malloc_state` 構造体、そのパラメータは `malloc_par` 構造体で定義されています。

```c
/* addressing -- note that bin_at(0) does not exist */
#define bin_at(m, i) \
  (mbinptr) (((char *) &((m)->bins[((i) - 1) * 2]))			      \
             - offsetof (struct malloc_chunk, fd))

// arena の実体
struct malloc_state
{
  __libc_lock_define (, mutex);     // arena へのアクセスを serialize する
  int flags;                        // ヒープメモリが連続であるか

  int have_fastchunks;              // fastbins が空ではないことを表す真偽値
  mfastbinptr fastbinsY[NFASTBINS]; // fastbins

  mchunkptr top;

  mchunkptr last_remainder;

  mchunkptr bins[NBINS * 2 - 2];    // unsortedbin smallbins largebins の先頭・末尾
  unsigned int binmap[BINMAPSIZE];  // smallbins largebinsで素早く見つける為に使われるビットベクタ

  struct malloc_state *next;        // arena の単方向リスト
  struct malloc_state *next_free;   // 使われていない arena の単方向リスト

  INTERNAL_SIZE_T attached_threads; // arena にアクセスしているスレッドの数

  INTERNAL_SIZE_T system_mem;       // arena によって現在確保されている書き込み可能なメモリの合計値
  INTERNAL_SIZE_T max_system_mem;   // system_mem の最大値
};
```

### malloc
`malloc()` -> `_libc__malloc()` -> `_int_malloc()`
`_libc__malloc()` では tcache を確認し、なければ `_int_malloc()` を呼び出します。
smallbin の範囲のとき
fastbin → smallbin → unsortedbin → 上位の bin → top → fastbin consolidate → unsortedbin
largebin の範囲のとき
fastbin consolidate → unsortedbin → largebin → 上位の bin → top → sysmalloc()
### free


### malloc hooks

これらのフックは heap exploit において非常に有用でしたが glibc v2.34 以降で削除されました。

- `__malloc_hook` / `__free_hook` / `__realloc_hook`
- `__after_morecore_hook`
- `__malloc_initialize_hook`
- `__memalign_hook`
- `_dl_open_hook`

## ヒープ領域での書き換え

ヒープ領域においては `fd` `bk` の書き換えが目標です。これができれば free list のリスト構造を壊すことができます。これによって malloc / free を繰り返すとそのアドレスへ書き換えが出来るようになります。

### Use After Free
free 関数が呼ばれた後でも読み書きが出来てしまう脆弱性。これが一番手っ取り早く `fd` `bk` の読み書きが出来ます。

解放されたメモリへのポインタを dangling pointer (ぶらさがったポインタ) と言います。

### Heap based Buffer Overflow
Heap 上での BOF です。複数回 malloc すると参照居所性などの理由から連続に並ぶことが多いです。そうすると使われているチャンクから BOF して別のチャンクの書き換えができるようになり、変数の書き換えや `fd` `bk` の書き換えが出来ます。

### double free

Use After Free や HBOF が出来なくとも double free させればリストがループするから適切に malloc した領域でも fd に意図したアドレスを書き込めるようになる。

glibc 2.28 以前の tcache では double free が検出されませんが、glibc 2.29 以降では `key` という `tcache_perthread_struct` 構造体を指すフィールドが追加され、double free 検査が入るようになった。

## ヒープ領域での攻撃方法

### tcache poisoning

tcache に入れたチャンクの next を書き換えて malloc することで AAW できる脆弱性。注意するべきは tcache が LIFO なリストな為に malloc free を繰り返さなければならない
tcache poisoning して `__free_hook` を書き換える。
同じ領域に悪意のあるデータ構造を確保して利用させる事で、関数ポインタを書き換える。

[SECCON Beginners CTF 2020 [Beginners Heap] Writeup &初心者向け解説 - Qiita](https://qiita.com/hanya1995/items/c29a89737bbd521e67f2)
[SECCON Beginners CTF 2019 - Babyheap - HackMD](https://hackmd.io/@Xornet/H1hYUUR2I)

### fastbins attack

### unsortedbin attack

- [Security Fest 2019 - Baby5 (Unsorted Bin) - HackMD](https://hackmd.io/@Xornet/rycqVwQpL)
- [n日1CTFチャレンジ - HackMD](https://hackmd.io/@Xornet/BkemeSAhU)

### House of Prime

fastbins の最大サイズ変数を破損させて、特定の状況下で攻撃者が arena 構造体をハイジャックし、その結果任意のメモリチャンクを返すか、
アイデア
2回の `free()` 、1回の `malloc()` の呼び出しができるとき

## まとめ
Heap Exploit をまとめました。今回は Linux のみの紹介になりましたが Microsoft の mimalloc とかもあります。
https://qiita.com/methane/items/e88901b7392c10cee2c9

これが出来るようになれば pwn 中級者と言えそうです。

## 参考資料
- https://github.com/shellphish/how2heap
- [Overview of GLIBC heap exploitation techniques](https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/)
- [【LCR 1.1】LibcCodeReading: malloc編[2]=fastbins・smallbins - newbie dive into binary (hatenablog.com)](https://smallkirby.hatenablog.com/entry/2019/09/23/001554)
