---
title: "Windows OS の緩和策をバイパスして制御を奪う入門"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn", "windows"]
published: false
---

pwn というのはメモリの書き換えや読み取りなどの低レイヤーの脆弱性を用いて意図しない動作を引き起こさせる競技で最もハッキングっぽい分野です。

- [Stack Exploits](https://zenn.dev/anko/articles/ctf-stack-exploits)
- [Heap Exploits](https://zenn.dev/anko/articles/ctf-heap-exploits)

今回は第一のステップとして Windows の DEP, ASLR, CFG, ACG, CET などのユーザーモードの緩和策をバイパスし、任意コード実行を目指します。

## Windows の基本
Windows とは Microsoft 社が開発・販売している OS の製品群です。それまで CUI だった MS-DOS から Windows 1.0 はタイル状の"ウィンドウ"を通してアプリケーションを操作する GUI となり、MacOS との対立を経て、現在デファクトスタンダードとなっている OS です。

| バージョン | 発売日 | 説明 |
| --- | --- | --- |
| Windows 1.x | 1985/11/20 | |
| Windows 2.x | 1987/12/9 | |
| Windows 3.x | 1990/5/22 | |
| Windows NT | 1993/7/27 | Graphics Device (GDI) |
| Windows 95 | 1995/8/24 |
| Windows 98 | 1998/6/25 |
| Windows 2000 | 1999/12/15 | 9x系 NT系の脆弱性は深刻な社会問題 |
| Windows XP | 2001/8/24 | Service Pack2 (SP2) はセキュリティ改良 |
| Windows Vista | 2006/11/30 | 酷評 |
| Windows 7 | 2009/9/1 |
| Windows 8 | 2012/8/16 |
| Windows 10 | 2015/7/29 | EMET サポート終了 Exploit Protection 開始 |
| Windows 11 | 2021/10/5 |

9x と混同するので Windows 9 はないです。

Windows における実行可能ファイルは Portable Executable (PE) フォーマットで書かれており、.exe, .dll, .scr, .cpl, .sys などの拡張子を持ちます。詳しい構造は [PE 形式](https://learn.microsoft.com/ja-jp/windows/win32/debug/pe-format)、[Peering Inside the PE: A Tour of the Win32 Portable Executable File Format](https://learn.microsoft.com/en-us/previous-versions/ms809762(v=msdn.10)) などを参照してください。実行可能ファイルに静的にライブラリをリンクするのに加え、動的にライブラリをリンクする Dynamic Link Library (DLL) があります。

この PE ファイルを実行するとプロセスが起動し、次のようなメモリレイアウトで展開されます。

![](/images/pwn/windows_process.png)

物理アドレスと仮想アドレスは MMU によってページ単位でマッピングされます。各ページは Read, Write, Execute, Guard の 4 種類の保護属性で守られ、違反すると例外が送出されます。特に Guard 属性のついたページはアクセスすると STATUS_GUARD_PAGE_VIOLATION という例外が送出されます。また仮想メモリで使っているように見える領域のほとんどは物理メモリで確保されておらず、Copy On Write の原則に従っています。

プロセス空間で主要な領域はスタック領域、ヒープ領域、Mapped File です。スタック領域とヒープ領域は Linux と同じようなものと考えればいいです。スタックはスレッドごとにあり、現在実行中のスレッドのスタックのみアクセスできて、その他のスタックには Guard 属性が付けられます。Mapped File はストレージにあるファイルの実体を仮想メモリにマップしたものです。上図で書かれてあるもの以外にも多くの構造体 (プロセスやスレッドの情報や環境変数など) が書かれてあるので VMMap で確認してみるといいです。

:::message
**演習問題**
Sysinternals の VMMap で色んなプロセスのメモリレイアウトを確認してみましょう。
:::

次に Windows アーキテクチャについて解説します。

上のように起動したプロセスは Windows API を通して OS と通信します。Windows API (元 Win32 API) とはファイルシステムやデバイス入出力、UI などを扱う Native API です。これらは `C:\Windows\System32\` 以下にある DLL (サブシステム DLL) で実装されていて Windows API の上に高レイヤーなフレームワークが実装されています。

![](/images/pwn/windows.png)

そして Ntdll.dll はサービスシステム (システムコール) を呼び出してユーザーモードからカーネルモードに移行し、カーネルに渡します。ちなみにカーネルモードで未処理の例外が発生したらシステムクラッシュし、ブルースクリーン (BSOD) が表示されます。

例えばプロセスから Windows API を用いてファイルを作成してみると次のような処理が走ります。

1. プロセスが fileapi.h の [CreateFileA 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/fileapi/nf-fileapi-createfilea) を呼び出す。
2. Kernel32.dll の [NtCreateFile 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/nf-winternl-ntcreatefile) を呼び出す。
3. Ntdll.dll で sysenter / syscall してカーネルモードへ移行する。
4. Ntoskrnl.exe の System Service Dispatch Table (SSDT) で I/O Manager の NtCreateFile 関数を呼び出す。
5. Driver.sys で I/O を実行して Handle を返す。

そういえば Windows では Handle という識別子でプロセスやファイルを扱います。

また Windows 以外にも Windows Subsystem for Linux 2 (WSL2) という

## ツール
Windows Exploit する上で非常に便利なツールたちを紹介します。

| アプリ | 説明 |
| --- | --- |
| [Visual Studio](https://visualstudio.microsoft.com/ja/vs/) | エディターとビルド環境を備えた IDE |
| [Sysinternals](https://learn.microsoft.com/ja-jp/sysinternals/) | Windows から提供されているツール群 |
| Process Explorer | Sysinternals のプロセスの特権や緩和策などの情報のユーティリティ |
| VMMap | Sysinternals のプロセス内の仮想メモリと物理メモリのユーティリティ |
| [pestudio](https://www.winitor.com/) | |
| [WinDbg](https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/debugger-download-tools) | Windows のスタンダードなデバッガ。基本これを使いながら攻撃を行う。 |
| [Microsoft Learn](https://learn.microsoft.com/en-us/) | Windows 関連の情報の検索エンジン |
| [Undocumented Functions](http://undocumented.ntinternals.net/) | Windows 公式が提供していない関数・構造体をまとめたサイト |
| [Terminus Project](http://terminus.rewolf.pl/terminus/) | Windows Internals の構造体の図解 |
| [Windows Driver Kit](https://learn.microsoft.com/ja-jp/windows-hardware/drivers/download-the-wdk) | |
| [Metasploit](https://www.metasploit.com/) | |
| [dumpbin コマンド](https://learn.microsoft.com/ja-jp/cpp/build/reference/dumpbin-reference) | PE 形式のファイルの構造をダンプするコマンド |

Windows 8 以降 Microsoft によって DLL のデバッグシンボルが大量に消されてしまった為、リバースエンジニアリングが難易度的にも法的にも困難になっています。私が調べたところでは最新の構造体がまとめられているサイトを見つけることが出来ませんでした。もし知っていらっしゃる方がいれば是非教えてください。

Windows 以外でも参考になるプロジェクトも紹介しておきます。

| プロジェクト | 説明 |
| --- | --- |
| ReactOS | Windows 互換の OS を目指している OSS ([ReactOS のリファレンス](https://doxygen.reactos.org/)) |
| Wine | Linux 上の Windows API のエミュレータ (Windows のエミュレータではない) |
| Boot Camp | Intel Mac でデュアルブートする為のツール |

## Windows Exploit の基本
OS は違えど基本的な構造は同じなので Linux と同じように攻撃できます。

- Buffer Overflow
- Format String Bug
- Return Oriented Programming
- shellcode
- vtable overwrite
- SEH overwrite

それに加え DLL に関して Windows 独自の攻撃手法があります。

- DLL leak
- DLL Injection
- APC
- IAT

Windows の exploit code は大きくなりがちなので極力「ROP < shellcode < DLL Injection」の順に攻撃したいという気持ちがあります。
### DLL leak
ROP やシェルコードで DLL の関数を呼ぶにはその関数のアドレスが必要になります。それを得る方法について正式な名称が見つからなかったので DLL leak と呼ぶことにします。ここでは次の 2 つの DLL leak の方法を紹介します。

- LoadLibrary 関数 / GetProcAddress 関数を呼ぶ
- TEB を歩いて見つける

1 つ目は簡単な方法で 2 つの関数を呼ぶだけです。

1. LoadLibrary または LdrLoadDll で DLL をロードし Handle を得る
2. GetProcAddress または LdrGetProcedureAddress で関数のアドレスを得る

そもそもこれらの関数アドレスがリーク出来てないとリークできませんが、とても簡単に得ることができる便利な方法です。

2 つ目はより汎用的な方法で Thread Environment Block (TEB) を利用する方法です。

1. TEB から DLL のベースアドレスを得る (ASLR のバイパス)
2. DLL 中の EAT / IAT から関数のアドレスを得る (バージョン依存性からの脱却)

Export Address Table (EAT) / Import Address Table (IAT) とは Export / Import する関数のアドレスを保持するテーブルです。DLL のバージョンが異なるとベースアドレスからのオフセットも異なりますが、EAT / IAT から読み取ればどんなバージョンでも攻撃でき、安定します。ここらへんの全体像は次の記事を読むのが良いです。

https://learn.microsoft.com/en-us/previous-versions/ms809762(v=msdn.10)

GS セグメントにある TEB 構造体から次のようにして DLL のベースアドレスが得られます。

| 型 | フィールドの型 | フィールド名 |
| --- | --- | --- |
| [TEB](https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/ns-winternl-teb) | PPEB | ProcessEnvironmentBlock |
| [PEB](https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/ns-winternl-peb) | PPEB_LDR_DATA | Ldr |
| [PEB_LDR_DATA](https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/ns-winternl-peb_ldr_data) | LIST_ENTRY | InMemoryOrderModuleList |
| [LDR_DATA_TABLE_ENTRY](https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/ns-winternl-peb_ldr_data) | PVOID | DllBase |

そして DLL の先頭にあるヘッダから DataDirectory[0] にアクセスした先に EAT (IMAGE_EXPORT_DIRECTORY) があります。

| 型 | フィールドの型 | フィールド名 |
| --- | --- | --- |
| IMAGE_DOS_HEADER | LONG | e_lfanew |
| [IMAGE_NT_HEADERS64](https://learn.microsoft.com/ja-jp/windows/win32/api/winnt/ns-winnt-image_nt_headers64) | IMAGE_OPTIONAL_HEADER32 | OptionalHeader |
| [IMAGE_OPTIONAL_HEADER64](https://learn.microsoft.com/ja-jp/windows/win32/api/winnt/ns-winnt-image_optional_header64) | IMAGE_DATA_DIRECTORY | DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] |
| [IMAGE_DATA_DIRECTORY](https://learn.microsoft.com/ja-jp/windows/win32/api/winnt/ns-winnt-image_data_directory) | DWORD | VirtualAddress |
| IMAGE_EXPORT_DIRECTORY | PDWORD * | AddressOfFunctions, AddressOfNames, AddressOfNameOrdinals |

1. AddressOfNames から関数の名前と一致するインデックスを見つける。
2. AddressOfNameOrdinals は AddressOfNames のインデックスから AddressOfFunctions のインデックスが手に入る。
3. AddressOfFunctions の 2 で得たインデックスに関数のアドレスがある。

:::message
**演習問題**
適当な実行ファイルを起動して WinDbg で Kernel32.dll の GetProcAddress のアドレスを見つけてください。
:::

### DLL Injection
DLL をプロセス空間にロードすることを DLL Injection といいます。これにより DllMain() を呼び出したり

> **AppInit DLLs**
> User32.dll が任意のプロセスでレジストリキー `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs` のパスにある DLL をロードする

> **CreateRemoteThread**
> [CreateRemoteThread 関数](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)
> OpenProcess関数でリモートプロセスのハンドルを取得する
> VirtualAllocEx関数でリモートプロセス上のメモリ領域を確保する
> 確保したメモリ領域にWriteProcessMemory関数でDLLのパス文字列を書き込む
> GetModuleHandle関数とGetProcAddress関数でkernel32.dll内にあるLoadLibrary関数のアドレスを取得する
> CreateRemoteThread関数でリモートプロセス上でLoadLibrary関数を実行し、指定したDLLを読み込ませる
> WaitForSingleObject関数でLoadLibrary関数の終了を待つ
> スレッドハンドルおよび確保したメモリ領域を解放する

> **Window Hooks**
> [SetWindowsHookEx 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/winuser/nf-winuser-setwindowshookexa) を呼ぶことで
> [フックプロシージャ](https://learn.microsoft.com/ja-jp/windows/win32/winmsg/about-hooks?redirectedfrom=MSDN#hook-procedures)
> CallNextHookEx 関数
> hMod に DLL を指定することでロードできる
> DLL の関数をグローバルフックに追加してイベントを発行することで実行され DLL インジェクションが成功します。


> **Winsock service providers**
> 遅延読み込みする DLL
> GDIPlus

DllMain()
reflective DLL Injection

http://dsas.blog.klab.org/archives/50829204.html

### とりあえず攻撃
Windows の PoC では最終的に電卓 (calc.exe) を起動することがよくあるのでそれに則って shellcode で電卓を起動してみましょう。

## プロセスの緩和策 (Mitigations)
Windows には Linux に比べて豊富なセキュリティ機構があります。それらの緩和策とそのバイパス方法を解説します。

### 緩和策の設定方法
一般的な緩和策の設定は次の 4 つの方法があります。

- [Set-ProcessMitigationPolicy 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy)
- [Set-ProcessMitigation コマンド](https://learn.microsoft.com/en-us/powershell/module/processmitigations/set-processmitigation)
- [リンカのオプション](https://learn.microsoft.com/ja-jp/cpp/build/reference/linker-options)
- 「Windows セキュリティ」→「セキュリティの概要」→「アプリとブラウザー コントロール」→「Exploit Protection の設定」

### Address Space Layout Randomization
プロセスの仮想メモリはページ単位で物理メモリとのマッピングが行われます。Address Space Layout Randomization (ASLR) とはマッピング仮想アドレスをランダム化する機構です。

Linux とは違い、スタックやヒープ、イメージなどのアドレスをランダム化します。これをバイパスするにはベースアドレスのリークが必要になります。

そして Bottom-up ASLR で VirtualAlloc 関数などで作られたページもランダム化し、 High Entropy ASLR で 64-bit アドレスを最大限にランダム化、ASLR Disallow Stripped Image で ASLR 無効な DLL イメージを読み込み禁止とします。

リンクオプション

- ASLR 有効 `/DYNAMICBASE`
- ASLR 無効 `/FIXED`
- High Entropy ASLR `/HIGHENTROYVA`

### Data Execution Prevention
Data Execution Prevention (DEP) とはスタックやヒープのページに実行属性を付けない機構、Arbitary Code Guard (ACG) とは [VirtualAlloc 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) や [VirtualProtect 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) などで実行属性がついたページを作成することを禁止する機構です。

DEP, ACG によりシェルコードの実行が難しくなるので ROP でバイパスします。

### Structured Exception Handling Overwrite Protection
プロセッサでエラーが起きると例外 (Exception) というイベントが発生します。それをカーネルがキャッチしてユーザープロセスの Structured Exception Handling (SEH) という例外ハンドラの機構に渡します。

Thread Environment Block (TEB) の先頭にある `NT_TIB` 構造体の `ExceptionList` という例外ハンドラのリンクリストから 1 つずつ例外ハンドラを呼び出します。そこで例外処理が成功したら終了し、失敗したら次の例外ハンドラに進み、末尾にある ntdll.dll の FinalExceptionHandler まで繰り返します。この機構を SEH と言います。

```c
struct NT_TIB {
  EXCEPTION_REGISTRATION_RECORD *ExceptionList;
  VOID *StackBase;
  VOID *StackLimit;
  VOID *SubSystemTib;
  union {
    VOID *FiberData;
    ULONG Version;
  };
  VOID *ArbitraryUserPointer;
  NT_TIB *Self;
}

struct EXCEPTION_REGISTRATION_RECORD {
  EXCEPTION_REGISTRATION_RECORD *Next;
  EXCEPTION_DISPOSITION *Handler;
}
```

そのリストの一部分がスタック上にあるので BOF を用いて Handler を書き換えて任意コード実行ができる SEH overwrite という攻撃手段がありました。

SafeSEH とはビルド時にあらかじめ例外ハンドラのアドレス一覧をバイナリファイルに埋め込んでおき、例外ハンドラ実行時に埋め込まれたアドレスと照合して一致しなければ実行されないという仕組みです。ただし検査するアドレスは SafeSEH が紐づいたイメージのアドレスとスタック領域上のアドレスのみです。なので SafeSEH 無効な DLL のアドレスとヒープ領域上のアドレスを例外ハンドラとすればバイパスできます。

Structured Exception Handling Overwrite Protection (SEHOP) とは SEH overwrite の緩和策で以下のことを保証します。

- すべてのレコードがスタック上にあり、align されていることを検査する。
- ハンドラがスタックを指していないことを検査する。
- リスト末尾が FinalExceptionHandler であるか検査する。

これより SEHOP のバイパスには FinalExceptionHandler のアドレスのリークが必要になります。

これらは 64 bit では無効になったので攻撃も緩和策も意味はないです。

### Control Flow Guard
最近は ROP さえも防ぐ Control Flow Integrity (CFI) 技術というものが発達していて、Windows では次の 3 つの CFI が施行されています。

- Control Flow Guard (CFG)
- CFG Export Suppression
- CallerCheck / SimExec

Control Flow Guard は call 命令の直前に Guard Control Flow Function Table に登録されているか検査する処理を加えます。これにより vtable overwrite などの実行アドレス書き換えを防ぎます。

スタック上で大きな ROP を組めないときに別の場所に飛ばしてそこで組むという Stack Pivot という攻撃手法があります。これに対して重要な関数の呼び出し時にスタックを指しているかをチェックするという緩和策があります。

通常 ret 命令で戻ったアドレスの直前には call 命令がありますが ROP の Gadget はそうではないという発想の元、CallerCheck / SimExec は重要な関数の ret 命令 / 重要な関数の直後 20 命令先までの ret 命令を検査します。このバイパスには call 命令の Gadget (例えば `call rax; ret`) の ret 命令を 19 回呼んだ後に call 命令を呼べばよいです。

さらに Windows 10 から CFG Export Suppression という EAT のアドレスを正規の手段で得たか検査する機構が加わりました。call, jmp 命令の直前に検査して不正な方法 `mov rax, [rax]` で得ているとクラッシュします。

- GetProcAddress 関数
- 静的リンク (IAT など)
- DLL 内で得る

これをバイパスするには正規の方法で獲得する Gadget を利用する必要があります。

Return Flow Guard という Shadow Stack のソフトウェア実装があったのですが race condition によってバイパスできるなどの要因で不採用となりました。

### Image Isolation
攻撃者はリモートの DLL や事前に仕込んだ悪意のある DLL を読み込ませることで楽に悪意のある関数を呼び出せます。これに対して DLL の読み込みを制限する緩和策はいくつかあります。

| 緩和策 | 説明 |
| --- | --- |
| Block Remote Images | UNC パスや WebDAV パスの DLL を禁止 |
| Block Low Integrity Images | 低い Integrity Level を持つ DLL を禁止 |
| Microsoft-Signed Binaries Only | Windows Hardware Quality Labs の CA によって電子証明されていない DLL を禁止 |
| Store-Signed Binaries Only | Microsoft Store の CA によって電子証明されていない DLL を禁止 |
| Prefer System32 Images | `${SYSTEM_ROOT}\System32` の DLL を先に探索する |
| Disable Extension Points | 拡張ポイントの読み込みを無効にする |

これらのバイパスは厳しそう (十分なリサーチができていない) なので既に読み込まれている DLL を使って ROP を組むことになるでしょう。

### Address Filter
Export Address Filter (EAF) / Import Address Filter (IAF) とは .text 領域以外から特定の DLL (kernel32.dll, ntdll.dll, kernelbase.dll) の EAT / IAT の読み取りを制限する機構です。

このバイパスには ROP を用いて妥当なコード領域から EAT にアクセスすればよいです。

NtContinue を呼ぶことで、EAF が利用しているデバッグレジスタをクリアする

### その他

| 緩和策 | 説明 |
| --- | --- |
| Disable Child Process Creation | 子プロセスを作成するのを禁止する |
| Disable Fsctl SystemCalls | |
| Disable Win32k system calls (from Windows 8) | Win32k.sys の呼び出しを禁止する |
| Validate handle usage | |
| Validate image dependency integrity | |
| Block Untrusted Fonts | Graphics Device Interface (GDI) のフォント解析による特権昇格 `%windir%\Fonts` 以外のフォントをロードしない |

Exploit Protection は主要な緩和策で他にも沢山の緩和策があります。

## まとめ
さらにより詳細で網羅的な Exploit や Malware の情報がまとまってる記事があります。

https://www.ired.team/offensive-security/code-injection-process-injection
https://github.com/pinksawtooth/how_to_become_a_malware_analyst

## 参考文献
- インサイド Windows
- Windows カーネルドライバプログラミング
- インサイド ExploitProtection
- [Customize Exploit Protection](https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/customize-exploit-protection)
- [SEH オーバーライトの防御機能とその Exploit 可能性](https://www.ffri.jp/assets/files/research/research_papers/SEH_Overwrite.pdf)
- [Windowsのセキュリティ新機能 Control Flow Guardについて](https://www.ffri.jp/assets/files/monthly_research/MR201412_Control_Flow_Guard_JPN.pdf)
- [Exploit Protection のリファレンス](https://learn.microsoft.com/ja-jp/microsoft-365/security/defender-endpoint/exploit-protection-reference)
- [脆弱性緩和技術の最前線](https://www.ffri.jp/assets/files/research/research_papers/recent_advances_vuln_mitig_jp.pdf)
- [Heap Exploitのこれまでと現状](https://www.ffri.jp/assets/files/monthly_research/MR201312_History%20and%20Current%20State%20of%20Heap%20Exploit_JPN.pdf)
- [Software defense: mitigating common exploitation techniques](https://msrc.microsoft.com/blog/2013/12/software-defense-mitigating-common-exploitation-techniques/)
- [MITRE ATT&CK - Privilege Escalation](https://attack.mitre.org/tactics/TA0004/)
- [Windows 10 Kernel Exploitation to the next level](https://www.blackhat.com/docs/us-17/wednesday/us-17-Schenk-Taking-Windows-10-Kernel-Exploitation-To-The-Next-Level%E2%80%93Leveraging-Write-What-Where-Vulnerabilities-In-Creators-Update.pdf)
- [Windows 10 Segment Heap Internals](https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals.pdf)
- [Windows 10 Segment Heap Internals](https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf)
- [Attacking Windows By Windows](https://www.blackhat.com/docs/eu-16/materials/eu-16-Liang-Attacking-Windows-By-Windows.pdf)
- [Windows Offender Reverse Engineering Windows Defenders Antivirus Emulator](https://i.blackhat.com/us-18/Thu-August-9/us-18-Bulazel-Windows-Offender-Reverse-Engineering-Windows-Defenders-Antivirus-Emulator.pdf)
- [インサイドWin32kエクスプロイト: Win32kの実装の背景とエクスプロイトの方法論](https://unit42.paloaltonetworks.jp/win32k-analysis-part-1/)
- [Into The Core: In-Depth Exploration of Windows 10 IoT Core](https://www.blackhat.com/docs/us-16/materials/us-16-Sabanal-Into-The-Core-In-Depth-Exploration-Of-Windows-10-IoT-Core-wp.pdf)
- [DLL Injection Part 1: SetWindowsHookEx](https://warroom.rsmus.com/dll-injection-part-1-setwindowshookex/)
- [DLL Injection Part 2: CreateRemoteThread and More](https://warroom.rsmus.com/dll-injection-part-2-createremotethread-and-more/)
