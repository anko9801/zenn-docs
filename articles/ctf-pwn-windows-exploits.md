---
title: "【CTF 探訪記】Windows Exploits"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn", "windows"]
published: false
---

pwn というのはメモリの書き換えや読み取りなどの低レイヤーの脆弱性を用いて意図しない動作を引き起こさせる競技で最もハッキングっぽい分野です。

- [Stack Exploits](https://zenn.dev/anko/articles/ctf-stack-exploits)
- [Heap Exploits](https://zenn.dev/anko/articles/ctf-heap-exploits)

今回は Windows の基本と緩和策の紹介をしようと思います。気が向いたら PoC も書きます。

ここでは 64 ビットシステムの Windows / Windows Server を対象にします。

## Windows の基本
Windows OS の歴史

| バージョン | 発売日 | 説明 |
| --- | --- | --- |
| Windows 1.x | 1985/11/20 |
| Windows 2.x | 1987/12/9 |
| Windows 3.x | 1990/5/22 |
| Windows NT | 1993/7/27 | Graphics Device (GDI) |
| Windows 95 | 1995/8/24 |
| Windows 98 | 1998/6/25 |
| Windows 2000 | 1999/12/15 | 9x系 NT系の脆弱性は深刻な社会問題 |
| Windows XP | 2001/8/24 | Service Pack2 (SP2) はセキュリティ改良 |
| Windows Vista | 2006/11/30 | |
| Windows 7 | 2009/9/1 |
| Windows 8 | 2012/8/16 |
| Windows 10 | 2015/7/29 | Block Untrusted Fonts, EMET サポート終了 Exploit Protection 開始 |
| Windows 11 | 2021/10/5 |

Service Pack
スレッドや I/O などには触れず
Windows は次のようなアーキテクチャとなっています。

![](/images/pwn/windows.png)

例えば

1. プロセスが Windows API の [CreateFileA 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/fileapi/nf-fileapi-createfilea) を呼び出す。
2. Kernel32.dll の [NtCreateFile 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/nf-winternl-ntcreatefile) を呼び出す。
3. Ntdll.dll で sysenter / syscall してカーネルモードへ移行する。
4. Ntoskrnl.exe の System Service Dispatch Table (SSDT) で I/O Manager の NtCreateFile 関数を呼び出す。
5. Driver.sys で I/O を実行して Handle を返す。

`C:\Windows\System32\drivers`
Linux でいうファイルディスクリプタやプロセス ID などは Windows では Handle という識別子で扱われます。
未処理の例外がカーネルモードで発生したらシステムクラッシュが生じ、ブルースクリーン (BSOD) が表示されます。
[Microsoft PE and COFF 仕様](https://learn.microsoft.com/ja-jp/windows/win32/debug/pe-format)
Win32k.sys (ウィンドウマネージャ, GDI)

| プロジェクト | 説明 |
| --- | --- |
| ReactOS | Windows 互換の OS を目指している OSS |
| Wine | Linux 上の Windows API のエミュレータ (Windows のエミュレータではない) |

## ツール
Windows 内部を解析する上で便利なツールを紹介します。

Windows は公式から [Sysinternals](https://learn.microsoft.com/ja-jp/sysinternals/) というツール群が提供されています。

| アプリ | 説明 |
| --- | --- |
| Process Explorer | 高機能なタスクマネージャ |
| VMMap | プロセス内の仮想メモリと物理メモリのユーティリティ |
| [pestudio](https://www.winitor.com/) | |
| [WinDbg](https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/debugger-download-tools) | Windows のスタンダードなデバッガ |
| [Microsoft Learn](https://learn.microsoft.com/en-us/) | Windows 関連の情報の検索エンジン |
| [Terminus Project](http://terminus.rewolf.pl/terminus/) | Windows Internals の構造体の図解 |
| [ReactOS Doxygen](https://doxygen.reactos.org/) | ReactOS のリファレンス |

## Windows Exploit の基本
OS は違えど基本的な構造は同じなので Linux と同じように攻撃できます。

ページの保護属性も Read, Write, Execute, Guard の 4 種類あり、Guard にアクセスすると STATUS_GUARD_PAGE_VIOLATION という例外が送出されます。
現在のスレッド以外のスタックに Guard 属性を付けて

| Shareable | プロセス間通信などによりプロセス間で共有可能なメモリ。 |
| Private Data | プロセスの仮想メモリから割り当てる VirtualAlloc 共有不可能なメモリ領域。 |

Environment variables

https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/ns-winternl-teb
https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/ns-winternl-peb


Linux でやった次の攻撃手法は同様に通ります。

- ROP
- shellcode
- vtable overwrite

電卓 (calc.exe) の起動が目標なことがよくあります。

### DLL Leak

| Thread Environment Block (TEB) | スレッドの情報を保持した構造体 |
| Process Environment Block (PEB) | プロセスの情報を保持した構造体 |

```c
typedef struct _TEB {
  NT_TIB          Tib;
  PVOID           EnvironmentPointer;
  CLIENT_ID       Cid;
  PVOID           ActiveRpcInfo;
  PVOID           ThreadLocalStoragePointer;
  PPEB            Peb;
  ULONG           LastErrorValue;
  ULONG           CountOfOwnedCriticalSections;
  PVOID           CsrClientThread;
  PVOID           Win32ThreadInfo;
  ULONG           Win32ClientInfo[0x1F];
  PVOID           WOW32Reserved;
  ULONG           CurrentLocale;
  ULONG           FpSoftwareStatusRegister;
  PVOID           SystemReserved1[0x36];
  PVOID           Spare1;
  ULONG           ExceptionCode;
  ULONG           SpareBytes1[0x28];
  PVOID           SystemReserved2[0xA];
  ULONG           GdiRgn;
  ULONG           GdiPen;
  ULONG           GdiBrush;
  CLIENT_ID       RealClientId;
  PVOID           GdiCachedProcessHandle;
  ULONG           GdiClientPID;
  ULONG           GdiClientTID;
  PVOID           GdiThreadLocaleInfo;
  PVOID           UserReserved[5];
  PVOID           GlDispatchTable[0x118];
  ULONG           GlReserved1[0x1A];
  PVOID           GlReserved2;
  PVOID           GlSectionInfo;
  PVOID           GlSection;
  PVOID           GlTable;
  PVOID           GlCurrentRC;
  PVOID           GlContext;
  NTSTATUS        LastStatusValue;
  UNICODE_STRING  StaticUnicodeString;
  WCHAR           StaticUnicodeBuffer[0x105];
  PVOID           DeallocationStack;
  PVOID           TlsSlots[0x40];
  LIST_ENTRY      TlsLinks;
  PVOID           Vdm;
  PVOID           ReservedForNtRpc;
  PVOID           DbgSsReserved[0x2];
  ULONG           HardErrorDisabled;
  PVOID           Instrumentation[0x10];
  PVOID           WinSockData;
  ULONG           GdiBatchCount;
  ULONG           Spare2;
  ULONG           Spare3;
  ULONG           Spare4;
  PVOID           ReservedForOle;
  ULONG           WaitingOnLoaderLock;
  PVOID           StackCommit;
  PVOID           StackCommitMax;
  PVOID           StackReserved;
} TEB, *PTEB;
```

### DLL Injection
DLL をロードして本来とは違う動作をさせる攻撃です。

次の関数を用いて DLL をロードします。

- Kernel32.LoadLibrary
- Kernel32.GetProcAddress
- ntdll.LdrLoadDll
- ntdll.LdrGetProcedureAddress


## ヒープ領域

C / C++ の malloc / new で

ヒープからのメモリ割り当て

HeapCreate
HeapAlloc
HeapFree

仮想メモリの直接の割り当て

VirtualAlloc
VirtualAllocEx

| Allocation Size | Granularity | Bucket |
| --- | --- | --- |
| 1 ~ 1,024 bytes (0x1 ~ 0x400) | 16 bytes | 1 ~ 64 |
| 1,025 ~ 2,048 bytes (0x401 ~ 0x800) | 64 bytes | 65 ~ 80 |
| 2,049 ~ 4,096 bytes (0x801 ~ 0x1000) | 128 bytes | 81 ~ 96 |
| 4,097 ~ 8,192 bytes (0x1001 ~ 0x2000) | 256 bytes | 97 ~ 112 |
| 8,193 ~ 16,368 bytes (0x2001 ~ 0x3FF0) | 512 bytes | 113 ~ 128 |

メモリ割り当ての API
CoTaskMemAlloc
GlobalAlloc
HeapAlloc
LocalAlloc
malloc
new
VirtualAlloc

eeap Terminate On Corruption
ヒープが破損した場合にプロセスを強制終了することによって、ヒープ破損の例外ハンドラを悪用する攻撃や時々ヒープの破損を起こす程度の Exploit を防御するという、ヒープの整合性を検証する機能*3。HeapSetInformation 関数

## プロセスの緩和策 (Mitigations)
Windows には Linux に比べて豊富なセキュリティ機構があります。

一般的な緩和策の設定は次の 4 つの方法があります。

- [Set-ProcessMitigationPolicy 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy)
- [Set-ProcessMitigation コマンド](https://learn.microsoft.com/en-us/powershell/module/processmitigations/set-processmitigation)
- [リンカのオプション](https://learn.microsoft.com/ja-jp/cpp/build/reference/linker-options)
- 「Windows セキュリティ」→「セキュリティの概要」→「アプリとブラウザー コントロール」→「Exploit Protection の設定」

さてどのような緩和策があるのか覗いてみましょう。

### Address Space Layout Randomization
プロセスの仮想メモリはページ単位で物理メモリとのマッピングが行われます。

Address Space Layout Randomization (ASLR) とはスタックやヒープ、実行領域などのアドレスをランダム化する機構です。ASLR 有効 `/DYNAMICBASE` では ROP が一段階難しくなり、これをバイパスするにはベースアドレスのリークが必要になります。

Force randomization for images (Mandatory ASLR)
Randomize memory allocations (Bottom-up ASLR)

そして Bottom-up ASLR で VirtualAlloc などで作られたページもランダム化し、High Entropy ASLR `/HIGHENTROYVA` で 64-bit アドレスを最大限にランダム化、ASLR Disallow Stripped Image で ASLR 無効 `/FIXED` な DLL イメージを読み込み禁止とするという機構です。

https://msrc.microsoft.com/blog/2013/12/software-defense-mitigating-common-exploitation-techniques/

### Data Execution Prevention
Data Execution Prevention (DEP) とはスタック領域やヒープ領域のページに実行権限を渡さない機構、 Arbitary Code Guard (ACG) とは [VirtualAlloc](https://learn.microsoft.com/ja-jp/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) や [VirtualProtect](https://learn.microsoft.com/ja-jp/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) などで実行属性がついたページを作成することを禁止する機構です。

- [SetProcessDEPPolicy 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/winbase/nf-winbase-setprocessdeppolicy)
- 「コントロールパネル」→「システム」→「システムの詳細設定」よりパフォーマンスの設定を開いて図 3.1 の画面で設定する方法。この画面では、BCD の nx オプションの値のうち、OptIn と OptOut に対応するような設定を行うことが可能。

### Structured Exception Handling Overwrite Protection
現在 64 ビットプロセスでは関係ない緩和策ですが一応紹介しておきます。

例外は命令を実行したときにプロセッサにエラーが起きて発生するイベントです。例外が発生するとカーネルがキャッチしてユーザープロセスの Structured Exception Handling (SEH) という例外ハンドラの機構に渡します。

スレッド環境ブロック (TEB) の先頭にある `NT_TIB` 構造体の `ExceptionList` という例外ハンドラのリンクリストから 1 つずつ例外ハンドラを呼び出します。そこで例外処理が成功したら終了し、失敗したら次の例外ハンドラに進み、末尾にある ntdll.dll の FinalExceptionHandler まで繰り返します。この機構を SEH と言います。

```c
struct NT_TIB {
  EXCEPTION_REGISTRATION_RECORD *ExceptionList;
  VOID *StackBase;
  VOID *StackLimit;
  VOID *SubSystemTib;
  union {
    VOID *FiberData;
    ULONG Version;
  };
  VOID *ArbitraryUserPointer;
  NT_TIB *Self;
}

struct EXCEPTION_REGISTRATION_RECORD {
  EXCEPTION_REGISTRATION_RECORD *Next;
  EXCEPTION_DISPOSITION *Handler;
}
```

そのリストの一部分がスタック上にあるので BOF を用いて Handler を書き換えて任意コード実行ができる SEH overwrite という攻撃手段がありました。

SafeSEH とはビルド時にあらかじめ例外ハンドラのアドレス一覧をバイナリファイルに埋め込んでおき、例外ハンドラ実行時に埋め込まれたアドレスと照合して一致しなければ実行されないという仕組みです。ただし検査するアドレスは SafeSEH が紐づいたイメージのアドレスとスタック領域上のアドレスのみです。なので SafeSEH 無効な DLL のアドレスとヒープ領域上のアドレスを例外ハンドラとすればバイパスできます。

Structured Exception Handling Overwrite Protection (SEHOP) とは SEH overwrite の緩和策で以下のことを保証します。

- すべてのレコードがスタック上にあり、align されていることを検査する。
- ハンドラがスタックを指していないことを検査する。
- リスト末尾が FinalExceptionHandler であるか検査する。

SEHOP のバイパスには FinalExceptionHandler のアドレスのリークが必要になります。

これは [dumpbin コマンド](https://learn.microsoft.com/ja-jp/cpp/build/reference/dumpbin-reference) で確認できます。

```shell
> dumpbin /LOADCONFIG <exe file>
```

### Control Flow Guard
Control Flow Integrity (CFI) 技術

Control Flow Guard は call 命令の直前に Guard Control Flow Function Table に登録されているか検査する処理を加えます。これにより vtable overwrite などの実行アドレス書き換えを防ぎます。

スタック上で大きな ROP を組めないときに別の場所に飛ばしてそこで組むという Stack Pivot という攻撃手法があります。これに対して重要な関数の呼び出し時にスタックを指しているかをチェックするという緩和策があります。

ret 命令で戻ったアドレスの直前には call 命令があるが ROP においては存在しないという発想の元、CallerCheck / SimExec は重要な関数の ret 命令 / 重要な関数の直後 20 命令先までの ret 命令で検査します。このバイパスには call 命令の Gadget (例えば `call eax; ret`) の ret 命令を 19 回呼んだ後に call 命令を呼べばよいです。

さらに Windows 10 から CFG Export Suppression という dll の export 関数のアドレスの call, jmp 命令の直前に正規の手段で得たか検査する処理クラッシュする機構が加わりました。

- GetProcAddress 関数
- 静的リンク (IAT など)
- dll 内で得る

GetProcAddress 関数のアドレスのリークさえも防がれる為、exploit はかなり難しくなります。

Return Flow Guard という Shadow Stack のソフトウェア実装があったのですが race condition によってバイパスできるなどの要因で不採用となりました。

### Image Isolation
DLL をロードさせることを DLL Injection といいます。
攻撃者はリモートの DLL イメージを読み込むことにより任意の攻撃を実行します
ROP より悪意ある関数にリターンする方が楽

DLL の読み込みを制限する緩和策はいくつかあります。

| 緩和策 | 説明 |
| --- | --- |
| Block Remote Images | UNC パスや WebDAV パスの DLL を禁止 |
| Block Low Integrity Images | 低い Integrity Level (IL) を持つ DLL を禁止 |
| Microsoft-Signed Binaries Only | Windows Hardware Quality Labs の CA によって電子証明されていない DLL を禁止 |
| Store-Signed Binaries Only | Microsoft Store の CA によって電子証明されていない DLL を禁止 |
| Prefer System32 Images | `${SYSTEM_ROOT}\System32` の DLL を先に探索する |

SetWindowsHookEx 関数で DLL の関数をグローバルフックに追加してイベントを発行することで実行され DLL インジェクションが成功します。Disable Extension Points とは プロセスが拡張ポイントの読み込みを無効にするというものです。

### Address Filter
Export Address Table (EAT) / Import Address Table (IAT) とは export / import する関数のアドレスを保持するテーブルです。

DLL のバージョンが異なるとベースアドレスからのオフセットも異なる為、シェルコードから EAT / IAT を読み取ることでより安定した攻撃ができます。

Export Address Filter (EAF) / Import Address Filter (IAF) とは .text 領域以外から特定の DLL (kernel32.dll, ntdll.dll, kernelbase.dll) の EAT / IAF の読み取りを制限する機構です。

### その他

| 緩和策 | 説明 |
| --- | --- |
| Disable Child Process Creation | 子プロセスを作成するのを禁止する |
| Disable Fsctl SystemCalls | |
| Validate handle usage | |
| Validate image dependency integrity | |
| Block Untrusted Fonts | Graphics Device Interface (GDI) のフォント解析による特権昇格 `%windir%\Fonts` 以外のフォントをロードしない |

## Kernel Exploit
権限昇格を

Kenrel の情報を NtQuerySystemInformation でリークできます。
NonPagedPool を実行可能で Kenrel mode から実行する

Window Function running in kernel mode
Overwrite HalDispatchTable function table with user-mode address

Disable Win32k system calls (Windows 8)
Win32k.sys の呼び出しを禁止する

## まとめ

https://github.com/pinksawtooth/how_to_become_a_malware_analyst

## 参考文献
- インサイド Windows
- Windows カーネルドライバプログラミング
- [Customize Exploit Protection](https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/customize-exploit-protection)
- [SEH オーバーライトの防御機能とその Exploit 可能性](https://www.ffri.jp/assets/files/research/research_papers/SEH_Overwrite.pdf)
- [Windowsのセキュリティ新機能 Control Flow Guardについて](https://www.ffri.jp/assets/files/monthly_research/MR201412_Control_Flow_Guard_JPN.pdf)
- [Exploit Protection のリファレンス](https://learn.microsoft.com/ja-jp/microsoft-365/security/defender-endpoint/exploit-protection-reference)
- [脆弱性緩和技術の最前線](https://www.ffri.jp/assets/files/research/research_papers/recent_advances_vuln_mitig_jp.pdf)
- [Heap Exploitのこれまでと現状](https://www.ffri.jp/assets/files/monthly_research/MR201312_History%20and%20Current%20State%20of%20Heap%20Exploit_JPN.pdf)
