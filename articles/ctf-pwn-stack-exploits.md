---
title: "【CTF 探訪記】Stack Exploit 技術"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn"]
published: true
---

pwn というのはメモリの書き換えや読み取りなどの低レイヤーの脆弱性を用いて意図しない動作を引き起こさせる競技で最もハッキングっぽい分野です。

- [Stack Exploits](https://zenn.dev/anko/articles/ctf-stack-exploits)
- [Heap Exploits](https://zenn.dev/anko/articles/ctf-heap-exploits)

今回はなぜ任意コード実行というものが出来るのかから始まり、Stack 領域に関する攻撃の話をしたいと思います。

## pwn でやること
pwn にはシェル起動や権限昇格、サンドボックスの脱出など問題のゴールは多岐に渡りますが、どの問題でもまずやるべきことは 1 つだけです。

**プログラムカウンタを奪取すること**

プログラムカウンタは次に実行する命令へのアドレスを格納しているレジスタで、x86-64 では rip、ARM や RISC-V では pc と呼ばれています。このプログラムカウンタを自由に書き換えられれば、実行領域に書かれてある機械語は何でも実行することができ、これを任意コード実行 (ACE; Arbitrary Code Execution) といいます。

一部を除いたほとんどの命令は実行されるとプログラムカウンタはその命令長だけ足され、次の命令へ移ります。分岐命令や call / ret 命令などの特殊な命令はプログラムカウンタを離れたアドレスへ飛ばすことが出来ます。このときスタック領域や TLS 領域などに書き込まれているアドレスへ飛ばすような命令が実行されるとき、そのアドレスを書き換えることで意図した場所へプログラムカウンタを飛ばすことが出来ます。これが任意コード実行の正体です。

また変数を書き換えることで分岐命令でのフローを変更させて意図した場所へ飛ばすことも考えられます。例えば次のような脆弱性でフローを変更させられることがあります。

- Integer Overflow
- Race Condition
- etc...

任意コード実行により pwn では普通は呼び出せない関数を呼び出したり、シェルを呼び出してファイルを読み書きしてフラグを取れます。

さて、そのようなメモリ領域に書かれてある実行アドレスは例えば次のようなものがあります。

- return address
- 関数アドレス
  - GOT
  - vtable
    - 動的ポリモーフィズムを実現する為に型と呼び出す関数のアドレスの対応表 vtable がバイナリ中にある。
  - フック関数

これらを自由に書き換える手段も必要です。任意のアドレスにあるデータを読めること、書き込めることをそれぞれ AAR; Arbitrary Address Read、AAW; Arbitrary Address Write といいます。

AAW の例としては

- `gets` などの文字列入力による BOF
- `printf` による Format String Bug での書き換え
- 配列の範囲外参照
- corrupted heap による書き換え
- etc...

AAR の例としては

- `puts`, `printf` 関数などで出力させる
- `_IO_FILE` 構造体の `IO_write_ptr` を書き換えて出力させる
- etc...

このような脆弱性を駆使して任意コード実行を実現させて、フラグを獲得を目指します。フラグは大抵ファイルに書き込まれているのでシステムコールや関数を呼び出して、シェルを起動したり、ファイルを読み込みます。例えば次の関数を呼び出すことで成功します。

- `system("/bin/sh")`
- `execve("/bin/sh", 0, 0)`
- `open("flag")` -> `read()`
- etc...

このようにして exploit が完了します。

ただし実際の問題はさまざなセキュリティ機構や限定された脆弱性などによって阻まれるので直線的には exploit 出来ません。なのでうまくバイパスするということも求められます。

## スタック領域における書き換え手段

### Out of bounds
C 言語において配列の外まで参照することができ、別の変数にまでアクセス出来てしまいます。これを配列の範囲外参照 (Out of bounds) といいます。

Rust や JavaScript などは境界チェックという配列に書き込む前にインデックスが正当な位置にあるかどうかを検査する機構がデフォルトであって範囲外参照を防げます。

### Buffer Overflow
Buffer Overflow とは配列範囲外まで入力を受け取ってしまう脆弱性で、通称 BOF と呼ばれます。

C 言語では `char buf[40]` と `char buf2[60]` を宣言したときに次の関数が脆弱性と成り得ます。

| 関数 | 挙動 | 脆弱性 |
| --- | --- | :-: |
| `scanf("%s", buf)` | 境界チェックせずに入力する。 | BOF |
| `scanf("%39s", buf)` | 39 バイト入力した後に NULL バイトを置く。 | safe |
| `scanf("%40s", buf)` | 40 バイト入力した後に NULL バイトを置く。 | one-byte BOF |
| `gets(buf)` | 境界チェックせずに入力する。 | BOF |
| `fgets(buf, 40, stdin)` | 39 バイト入力した後に NULL バイトを置く。 | safe |
| `read(stdin, buf, 40)` | 40 バイト入力した後に NULL バイトを置かない。 | leakable |
| `fread(buf, 1, 40, stdout)` | 40 バイト入力した後に NULL バイトを置かない。 | leakable |
| `strcpy(buf, buf2)` | 境界チェックせずに文字列をコピーする。 | BOF |
| `strncpy(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `memcpy(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `memmove(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `strcat(buf, buf2)` | 境界チェックせずに文字列を `buf` に連結する。 | BOF |
| `strncat(buf, buf2, 10)` | 10 バイト連結した後に NULL バイトを置かない。 | BOF |
| `sprintf(buf, format, ...)` | 書式を適用した文字列を境界チェックせずに入力した後に NULL バイトを置く。 | BOF |
| `snprintf(buf, 40, format, ...)` | 書式を適用した文字列を 39 バイト入力した後に NULL バイトを置く。 | safe |

ちなみに NULL バイトだけ BOF できることは一見 exploit に繋がらなさそうに見えます。しかしこれはアドレスの下位 1 バイトを 0x00 に書き換えられるという能力を持ち、アドレスを若干ずらして書き換え可能な領域へ指すようになればデータを書き換えられるようになります。

```c
#include <stdio.h>

int main() {
    char buf[8];
    char target[] = "target value";
    gets(buf);
    printf("%s\n", target);
    return 0;
}
```

```shell
$ gcc bof.c
$ ./a.out

target value
$ ./a.out
AAAAAAAABOF
BOF
```

### Format String Bug

`printf` 関数の第一引数は書式 (Format String) といい、`%` から始まるプレースホルダーによって引数に対して文字列処理を行い、埋め込みます。

```c
%[parameter][flags][width][.precision][length]type
```

| フィールド | 具体例 | 説明 |
| --- | --- | --- |
| parameter | `6$` | 第二引数以降の引数の番号を表す。通常、書式が呼ばれる度インクリメントされるがこれによって一気に飛ばすことが出来る。x86-64 では 6 以降はスタックを指す。 |
| width | `40` `*` | 出力するバイト長を表す。 |
| length | `hh` `h` `l` | 入力する長さを表す。具体例はそれぞれ 1, 2, 8 バイトを表している。 |
| type | `d` `x` `p` `s` `n` ... | データをどのように解釈するかや書き込みなどを表す。 |

https://en.wikipedia.org/wiki/Printf#Format_placeholder_specification

例えば次のような例があります。

- `%42x` は unsigned int を 16 進数として 42 文字出力する。余った文字は空白となる。
- `%6$p` は第 7 引数、つまりスタック上の値をポインタとして出力する。
- `%s` は引数のアドレスから文字列として NULL バイトまで出力する。
- `%hhn` は引数のアドレスにこれまで出力した文字数を 1 バイト書き込む。Overflow するので一周すれば任意の値を書き込める。

```c
#include <stdio.h>

char target[40] = "target value";

int main() {
    char buf[40];
    fgets(buf, 40, stdin);
    printf(buf, target, target + 1, target + 2);
    printf("%s\n", target);
    return 0;
}
```
```shell
$ gcc fsb.c
$ ./a.out
%p
0x55f90f928020
target value
$ ./a.out
%70x%1$hhn%13x%2$hhn%65519x%3$hn
...
FSB
```

## スタック領域における攻撃方法

### 呼び出し規約
攻撃を始める前に関数を呼び出した際の処理を知っておかないと理解できません。

`call` 命令によって関数が呼び出されたとき、次の命令の実行アドレス (リターンアドレス) をスタックに push しておき、引数は次のようにセットされます。ローカル変数はスタック上に確保され、 `ret` 命令でスタックから pop して rip に入れます。

| 利用 | x86-64 | ARM | RISC-V |
| --- | --- | --- | --- |
| 関数の戻り値 | rax | r0 | ra |
| syscall 番号 | rax | r7 | a7 |
| 第 1 引数 | rdi | r0 | a0 |
| 第 2 引数 | rsi | r1 | a1 |
| 第 3 引数 | rdx | r2 | a2 |
| 第 4 引数 | r10 | r3 | a3 |
| 第 5 引数 | r8 | | a4 |
| 第 6 引数 | r9 | | a5 |
| スタックポインタ | rsp | r13 | sp |
| プログラムカウンタ | rip | pc | pc |

### リターンアドレスの書き換え
リターンアドレスを書き換えれば好きな場所へ飛ばすことができます。

- [単純なスタックバッファオーバーフロー攻撃をやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/03/14/151011)

例えば Out of bounds でリターンアドレスにアクセスして `win()` アドレスに書き換えれば処理が終わった後に `win()` が呼ばれます。その後スタックが壊れてしまったので無理やりリターンすると変なアドレスに飛び、そこが実行領域ではないとき Segmentation fault と出ます。

```c
#include <stdio.h>

void win() {
    printf("win!\n");
}

int main() {
    void* a[4] = {};
    printf("ret addr: %p\n", a[7]);
    printf("win func: %p\n", win);
    a[7] = win;
    printf("overwrited ret addr: %p\n", a[7]);
    return 0;
}
```
```shell
$ gcc retaddr.c
$ ./a.out
ret addr: 0x7f8b28229d90
win func: 0x55d6655bd189
overwrited ret addr: 0x55d6655bd189
win!
Segmentation fault
```

### シェルコード

機械語 (shellcode) をスタック上に埋め込み、rip をそこに飛ばします。スタックアドレスが分かっている必要があります。

- `system("/bin/sh")`
- `execve("/bin/sh", 0, 0)`
- `open("flag") -> read() -> write()`
  - chroot 環境で `/bin/sh` がなかったり、seccomp によってシステムコールを制限されているときに使います。

アセンブリから機械語へ変換する必要があるので `nasm` などのアセンブラに通したり、規格書にあるまとまった情報から読み取る必要があります。

- [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
- [図式された x86 の命令集](https://hikalium.github.io/opv86/)
- [ARM Architecture Reference Manual](https://documentation-service.arm.com/static/5f8dacc8f86e16515cdb865a)
- [The RISC-V Instruction Set Manual](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf)

### GOT overwrite
実行時にリンクするライブラリ (動的ライブラリ) はヒープ領域上にランダムに置かれます。そのアドレスを解決して呼び出すキャッシュ機構が GOT / PLT です。

- GOT (Global Offset Table)
  - 最初は PLT へのアドレスの表となっていて、アドレス解決後は直接ライブラリへのアドレスが書き込まれる
- PLT (Procedure Linkage Table)
  - アドレスを解決し、ライブラリを呼び出す関数表

より詳細な処理は長くなるので略します。

要するにこの GOT を書き換えることでライブラリを呼び出したときに rip を奪取できます。

また PLT のアドレスをリターンアドレスへ書き込むことでライブラリに飛ばすことを ret2plt といいます。

```shell
pwndbg> got

GOT protection: Full RELRO | GOT functions: 3

[0x55a3cb9f2fc0] free@GLIBC_2.2.5 -> 0x7fda9a390740 (free) ◂— endbr64
[0x55a3cb9f2fc8] __stack_chk_fail@GLIBC_2.4 -> 0x7fda9a4213b0 (__stack_chk_fail) ◂— endbr64
[0x55a3cb9f2fd0] malloc@GLIBC_2.2.5 -> 0x7fda9a390130 (malloc) ◂— endbr64
```

## セキュリティ機構

スタック領域やプロセス全体として NX, ASLR, RELRO, PIE, Stack Canary などのセキュリティ機構 (Mitigations) があります。

これらを ELF ファイルから調べてくれる checksec というスクリプトがあります。pwndbg の `checksec` コマンドもエイリアスとしてあります。

https://github.com/slimm609/checksec.sh

```shell
$ checksec --file=a.out
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable   FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   38) Symbols       No    0               0    a.out
```

### Stack-Smashing Protection

関数呼び出し時に return address の次に Master Canary から得られるランダムな値 (Canary) を配置し、return 前に Canary が変化したか検証し、変わっていたら`__stack_chk_fail` 関数を呼び出して例外を送出します。

https://www.youtube.com/watch?v=UTC2iWxQ4qc

### NX bit (No eXecute bit)
読み書きのフラグの他に CPU が特定のセグメントを実行できないようにするフラグを追加します。ソフトウェア上で W^X (Write xor Execute) が成り立つようにフラグを立てることで shellcode による攻撃は完全に出来ないようになりました。Windows では DEP (Data Execution Prevention) と呼ばれています。このフラグを書き換えるには Linux の場合 mprotect(2)、Windows の場合 VirtualProtectEx 関数が使えます。

### RELRO (RELocation Read-Only)
glibc などの動的ライブラリをリンクするとき、lazy binding といってシンボル名の検索とアドレスの解決については呼び出し時まで遅延させてプログラムの起動を早めます。ただ GOT overwrite と呼ばれる脆弱性が生まれる為、起動時に全て行い、書き込み禁止とするのが RELRO です。

|  | lazy binding | RELRO |
| --- | --- | --- |
| No RELRO | Yes | No |
| Partial RELRO | Yes | Yes |
| Full RELRO | No | Yes |

### ASLR (Address Space Layout Randomization)

スタックやヒープ、動的ライブラリが置かれるベースアドレスをランダムに決める機構です。

```
$ cat /proc/<process ID>/maps              // = gdb の i proc map = pwndbg の vmmap
```

### PIE (Position-Independent Executables)

実行ファイルそのものが置かれるベースアドレスをランダムに決める機構です。

### ASCII-armor

共有ライブラリのベースアドレスを `0x00XXXXXX` のように `\x00` を含めることで BOF によって書き込むことを難しくする機構です。

### Control Flow Integrity

ROP, JOP 対策として導入された主に CPU のセキュリティ機構です。Intel, ARM, RISC-V における CFI (Control Flow Integrity) 拡張をまとめます。

- Intel CET Shadow Stack
    - call 命令で return address を shadow stack に push し、ret 命令で pop して一致しなければ例外を送出する。既存のコードを変更せずに適用できるのが強み。
- Intel CET Indirect Branch Tracking (IBT)
    - jump 先に endbranch 命令を埋め込み、関数ポインタの先が endbranch 命令を指していない場合には例外が送出される機構。JOP の検知ができる。
- ARM Branch Target Identification (BTI)
    - br/blr 命令によって jump した先が bti 命令以外であれば例外を送出する機構。PTE の GP ビットが立っているときにそのアドレス範囲での BTI が有効になる。JOP の検知ができる。
- ARM Pointer Authentication (PAC)
    - PAC 命令で 64 bit ポインタの上位 8 bit にタグ, 3-23 bit にアドレスの署名を埋め込み、AUTH 命令で認証し、無効な署名を持つ場合に例外が送出される機構。署名は QARMA アルゴリズムが推奨されている。ROP の検知ができる。
- ARM Memory Tagging Extension (MTE)
    - メモリにタグを割り当て、ポインタの上位 4 bit にタグを埋め込み、アクセス時にそれらが不一致の場合には例外が送出される機構。Use After Free の検知ができる。
- RISC-V CFI Shadow Stack
    - 特殊なメモリ領域に Shadow Stack を確保し、return address のみの読み書きをする。sspush, sspop, sschkra 命令によって return address のプッシュ、ポップ、比較をし、不一致ならば例外を送出する。
- RISC-V CFI Landing Pads
    - 新しい命令 lpsll, lpcll 命令を追加して jalr 命令の分岐前と分岐後で label を照合することで想定された組み合わせかどうかを判定し、不一致なら例外を送出する。デメリットとしてツールチェイン側が実装する際にバグが発生しそうなことが挙げられる。

## セキュリティ機構のバイパス

### libc leak

ASLR + PIE によって Stack, Heap, libc, 実行領域などのベースアドレスがランダム化され、exploit が難しくなります。しかし、関数・データ間のオフセットは同じであるため、例えば次のようにしてベースアドレスを取得できます。

- スタックに積まれたリターンアドレスの値から、実行ファイルのベースアドレスが計算できる。
- 一度呼び出されたライブラリ関数のGOTアドレスの値から、そのライブラリのベースアドレスが計算できる。
- スタックに積まれたsaved ebpの値から、スタック領域に置かれる他のデータのアドレスが計算できる。
- ヒープ領域に確保されたデータを指すポインタの値から、ヒープ領域のベースアドレスが計算できる。

特に libc のベースアドレスを求めることは大変重要で、 libc leak といいます。libc leak できると例えばライブラリを呼び出したり (ret2libc)、文字列 `/bin/sh` も libc 内にあるのでシェル起動が簡単になります。

```python
from pwn import *

libc = ELF('libc.so')
system_offset = libc.symbols['system']
sh_offset = next(libc.search('sh\x00'))
binsh_offset = next(libc.search('/bin/sh\x00'))
```

### ROP (Return-Oriented Programming)

ret 命令で終わる少ない命令列 (Gadget) が機械語の中にあるのでそれを return address の書き換えで呼び出す攻撃手法です。

```nasm
; gadget 1
pop rdi
ret
; gadget 2
pop rsi
ret
; gadget 3
pop rdx
ret
; gadget 4
pop rax
ret
; gadget 5
syscall
ret
```

NX bit に対するバイパスで Shellcode なしでレジスタに値を書き込めるようになった。

呼び出す関数の引数がスタックを使用し、その後 2 つ以上の関数を呼ぶ場合は引数が Gadget と被らないように引数を削除する `pop ret` ガジェットを挟む。

また ROP Gadget を見つける際に重宝するツールがあります。

https://github.com/david942j/one_gadget
https://github.com/JonathanSalwan/ROPgadget

```shell
$ ROPgadget --binary ./chall

$ one_gadget ./libc.so.6
0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

0x4f322 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a38c execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
```

## ツール
ローカルで実行バイナリを動かして解析したいときデバッガーが重宝します。ELF のデファクトスタンダードなデバッガーは gdb で、使い方は他の記事を参考にしてください。

また、gdb に拡張的な機能を与えるプラグインも開発されていて、現在、主要なプラグインは次のようなものです。全部セットで入れられるインストーラーもあります。

- gdb-peda
- pwndbg (コマンドが豊富でおすすめ)
- gef

https://github.com/apogiatzis/gdb-peda-pwndbg-gef

大抵の問題は `nc` コマンドでサーバーに接続してバイナリが実行されるような形式で主題され、実行バイナリやソースコードも配られることもあります。この通信を簡単に取り扱いたい、またバイナリを解析したいというモチベーションで作られた pwntools、そしてそれを改良した ptrlib という Python のパッケージがあります。このような便利なパッケージが多く、言語は Python が選ばれやすいです。

https://github.com/Gallopsled/pwntools
https://github.com/ptr-yudai/ptrlib

pwn で私がいつも使っている Python のテンプレートです。

```python
from pwn import *
import sys

binary_path = './chall'

if len(sys.argv) == 3:
    io = remote(sys.argv[1], int(sys.argv[2]))
else:
    io = process(binary_path)
elf = ELF(binary_path)
# libc = ELF("./libc.so.6")

def wait_for_attach():
    print('attach?')
    raw_input()

payload = b''
io.sendlineafter(b'> ', payload)
io.recvline()
io.interactive()
```

# まとめ
スタック領域に関する exploit は pwn の begginer / easy レベルに当たるので解けるようになると初心者脱却できると思います。

次はヒープ領域に関する exploit です。少し難しいですが基本的にはここでやった考え方と同じなのでよく理解して挑んでください。
