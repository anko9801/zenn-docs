---
title: "【CTF 探訪記】Stack Exploit 技術"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn"]
published: true
---

pwn というのはメモリの書き換えや読み取りなどの低レイヤーの脆弱性を用いて意図しない動作を引き起こさせる競技で最もハッキングっぽい分野です。

- [Stack Exploits](https://zenn.dev/anko/articles/ctf-stack-exploits)
- [Heap Exploits](https://zenn.dev/anko/articles/ctf-heap-exploits)

今回はなぜ任意コード実行というものが出来るのかから始まり、Stack 領域に関する攻撃の話をしたいと思います。

## pwn でやること
pwn にはシェル起動や権限昇格、サンドボックスの脱出など問題のゴールは多岐に渡りますが、どの問題でもまずやるべきことは 1 つだけです。

**プログラムカウンタを奪取すること**

プログラムカウンタは次に実行する命令へのアドレスを格納しているレジスタで、x86-64 では rip、ARM や RISC-V では pc と呼ばれています。このプログラムカウンタを自由に書き換えられれば、実行領域に書かれてある機械語は何でも実行することができ、これを任意コード実行 (ACE; Arbitrary Code Execution) といいます。

一部を除いたほとんどの命令は実行されるとプログラムカウンタはその命令長だけ足され、次の命令へ移ります。分岐命令や call / ret 命令などの特殊な命令はプログラムカウンタを離れたアドレスへ飛ばすことが出来ます。このときスタック領域や TLS 領域などに書き込まれているアドレスへ飛ばすような命令が実行されるとき、そのアドレスを書き換えることで意図した場所へプログラムカウンタを飛ばすことが出来ます。これが任意コード実行の正体です。

また変数を書き換えることで分岐命令でのフローを変更させて意図した場所へ飛ばすことも考えられます。例えば次のような脆弱性でフローを変更させられることがあります。

- Integer Overflow
- Race Condition
- etc...

任意コード実行により pwn では普通は呼び出せない関数を呼び出したり、シェルを呼び出してファイルを読み書きしてフラグを取れます。

さて、そのようなメモリ領域に書かれてある実行アドレスは例えば次のようなものがあります。

- return address
- 関数アドレス
  - GOT
  - vtable
    - 動的ポリモーフィズムを実現する為に型と呼び出す関数のアドレスの対応表 vtable がバイナリ中にある。
  - フック関数

これらを自由に書き換える手段も必要です。任意のアドレスにあるデータを読めること、書き込めることをそれぞれ AAR; Arbitrary Address Read、AAW; Arbitrary Address Write といいます。

AAW の例としては

- `gets` などの文字列入力による BOF
- `printf` による Format String Bug での書き換え
- 配列の範囲外参照
- corrupted heap による書き換え
- etc...

AAR の例としては

- `puts`, `printf` 関数などで出力させる
- `_IO_FILE` 構造体の `IO_write_ptr` を書き換えて出力させる
- etc...

このような脆弱性を駆使して任意コード実行を実現させて、フラグを獲得を目指します。フラグは大抵ファイルに書き込まれているのでシステムコールや関数を呼び出して、シェルを起動したり、ファイルを読み込みます。例えば次の関数を呼び出すことで成功します。

- `system("/bin/sh")`
- `execve("/bin/sh", 0, 0)`
- `open("flag")` -> `read()`
- etc...

このようにして exploit が完了します。

ただし実際の問題はさまざなセキュリティ機構や限定された脆弱性などによって阻まれるので直線的には exploit 出来ません。なのでうまくバイパスするということも求められます。

## スタック領域における書き換え手段

### Out of bounds
C 言語において配列の外まで参照することができ、別の変数にまでアクセス出来てしまいます。これを配列の範囲外参照 (Out of bounds) といいます。

Rust や JavaScript などは境界チェックという配列に書き込む前にインデックスが正当な位置にあるかどうかを検査する機構がデフォルトであって範囲外参照を防げます。

### Buffer Overflow
Buffer Overflow とは配列範囲外まで入力を受け取ってしまう脆弱性で、通称 BOF と呼ばれます。

C 言語では `char buf[40]` と `char buf2[60]` を宣言したときに次の関数が脆弱性と成り得ます。

| 関数 | 挙動 | 脆弱性 |
| --- | --- | :-: |
| `scanf("%s", buf)` | 境界チェックせずに入力する。 | BOF |
| `scanf("%39s", buf)` | 39 バイト入力した後に NULL バイトを置く。 | safe |
| `scanf("%40s", buf)` | 40 バイト入力した後に NULL バイトを置く。 | one-byte BOF |
| `gets(buf)` | 境界チェックせずに入力する。 | BOF |
| `fgets(buf, 40, stdin)` | 39 バイト入力した後に NULL バイトを置く。 | safe |
| `read(stdin, buf, 40)` | 40 バイト入力した後に NULL バイトを置かない。 | leakable |
| `fread(buf, 1, 40, stdout)` | 40 バイト入力した後に NULL バイトを置かない。 | leakable |
| `strcpy(buf, buf2)` | 境界チェックせずに文字列をコピーする。 | BOF |
| `strncpy(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `memcpy(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `memmove(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `strcat(buf, buf2)` | 境界チェックせずに文字列を `buf` に連結する。 | BOF |
| `strncat(buf, buf2, 10)` | 10 バイト連結した後に NULL バイトを置かない。 | BOF |
| `sprintf(buf, format, ...)` | 書式を適用した文字列を境界チェックせずに入力した後に NULL バイトを置く。 | BOF |
| `snprintf(buf, 40, format, ...)` | 書式を適用した文字列を 39 バイト入力した後に NULL バイトを置く。 | safe |

ちなみに NULL バイトだけ BOF できることは一見 exploit に繋がらなさそうに見えます。しかしこれはアドレスの下位 1 バイトを 0x00 に書き換えられるという能力を持ち、アドレスを若干ずらして書き換え可能な領域へ指すようになればデータを書き換えられるようになります。

```c
#include <stdio.h>

int main() {
    char buf[8];
    char target[] = "target value";
    gets(buf);
    printf("%s\n", target);
    return 0;
}
```

```shell
$ gcc bof.c
$ ./a.out

target value
$ ./a.out
AAAAAAAABOF
BOF
```

### Format String Bug

`printf` 関数の第一引数は書式 (Format String) といい、`%` から始まるプレースホルダーによって引数に対して文字列処理を行い、埋め込みます。

```c
%[parameter][flags][width][.precision][length]type
```

| フィールド | 具体例 | 説明 |
| --- | --- | --- |
| parameter | `6$` | 第二引数以降の引数の番号を表す。通常、書式が呼ばれる度インクリメントされるがこれによって一気に飛ばすことが出来る。x86-64 では 6 以降はスタックを指す。 |
| width | `40` `*` | 出力するバイト長を表す。 |
| length | `hh` `h` `l` | 入力する長さを表す。具体例はそれぞれ 1, 2, 8 バイトを表している。 |
| type | `d` `x` `p` `s` `n` ... | データをどのように解釈するかや書き込みなどを表す。 |

https://en.wikipedia.org/wiki/Printf#Format_placeholder_specification

例えば次のような例があります。

- `%42x` は unsigned int を 16 進数として 42 文字出力する。余った文字は空白となる。
- `%6$p` は第 7 引数、つまりスタック上の値をポインタとして出力する。
- `%s` は引数のアドレスから文字列として NULL バイトまで出力する。
- `%hhn` は引数のアドレスにこれまで出力した文字数を 1 バイト書き込む。Overflow するので一周すれば任意の値を書き込める。

```c
#include <stdio.h>

char target[40] = "target value";

int main() {
    char buf[40];
    fgets(buf, 40, stdin);
    printf(buf, target, target + 1, target + 2);
    printf("%s\n", target);
    return 0;
}
```
```shell
$ gcc fsb.c
$ ./a.out
%p
0x55f90f928020
target value
$ ./a.out
%70x%1$hhn%13x%2$hhn%65519x%3$hn
...
FSB
```

## スタック領域における攻撃方法

### アセンブリと ABI
アセンブリとは機械語を人間に読みやすくしたものです。

アセンブリと機械語の対応やレジスタの情報などは CPU の規格書に書かれてあるのですが読んでみるとめっっっっっっちゃ長いです。なのでここでは Stack Exploit において特に重要なアセンブリ命令とレジスタを紹介します。

- [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
- [ARM Architecture Reference Manual](https://documentation-service.arm.com/static/5f8dacc8f86e16515cdb865a)
- [The RISC-V Instruction Set Manual](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf)

関数を呼んだときどのような処理が行われているのかを知っておくと攻撃の見通しが大分良くなるのでそれ関連のアセンブリ命令は次のようなものがあります。

| 命令 | 説明 |
| --- | --- |
| `push` | `*rsp = value; rsp += 8` |
| `pop` | `rsp -= 8; register = *rsp` |
| `call` | 関数が呼び出されたとき、次の命令の実行アドレス (リターンアドレス) をスタックに push しておき、引数は次のようにセットされます。 |
| `ret` | スタックから pop して rip に入れます。 |

ローカル変数はスタック上に確保される

| 目的 | x86-64 | ARM | RISC-V |
| --- | --- | --- | --- |
| 関数の戻り値 | rax | r0 | ra |
| syscall 番号 | rax | r7 | a7 |
| 第 1 引数 | rdi | r0 | a0 |
| 第 2 引数 | rsi | r1 | a1 |
| 第 3 引数 | rdx | r2 | a2 |
| 第 4 引数 | r10 | r3 | a3 |
| 第 5 引数 | r8 | | a4 |
| 第 6 引数 | r9 | | a5 |
| スタックポインタ | rsp | r13 | sp |
| プログラムカウンタ | rip | pc | pc |

### リターンアドレスの書き換え
リターンアドレスを書き換えれば好きな場所へ飛ばすことができます。

- [単純なスタックバッファオーバーフロー攻撃をやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/03/14/151011)

例えば Out of bounds でリターンアドレスにアクセスして `win()` アドレスに書き換えれば処理が終わった後に `win()` が呼ばれます。その後スタックが壊れてしまったので無理やりリターンすると変なアドレスに飛び、そこが実行領域ではないとき Segmentation fault と出ます。

```c
#include <stdio.h>

void win() {
    printf("win!\n");
}

int main() {
    void* a[4] = {};
    printf("ret addr: %p\n", a[7]);
    printf("win func: %p\n", win);
    a[7] = win;
    printf("overwrited ret addr: %p\n", a[7]);
    return 0;
}
```
```shell
$ gcc retaddr.c
$ ./a.out
ret addr: 0x7f8b28229d90
win func: 0x55d6655bd189
overwrited ret addr: 0x55d6655bd189
win!
Segmentation fault
```

### シェルコード

機械語 (shellcode) をスタック上に埋め込み、rip をそこに飛ばします。スタックアドレスが分かっている必要があります。

- `system("/bin/sh")`
- `execve("/bin/sh", NULL, NULL)`
- `open("flag") -> read() -> write()`
  - chroot 環境で `/bin/sh` がなかったり、seccomp によってシステムコールを制限されているときに使います。

[図式された x86 の命令集](https://hikalium.github.io/opv86/)

### GOT overwrite
実行時にリンクするライブラリ (動的ライブラリ) はヒープ領域上にランダムに置かれます。そのアドレスを解決して呼び出すキャッシュ機構が GOT / PLT です。

- GOT (Global Offset Table)
  - 最初は PLT へのアドレスの表となっていて、アドレス解決後は直接ライブラリへのアドレスが書き込まれる
- PLT (Procedure Linkage Table)
  - アドレスを解決し、ライブラリを呼び出す関数表

より詳細な処理は長くなるので略します。

要するにこの GOT を書き換えることでライブラリを呼び出したときに rip を奪取できます。

また PLT のアドレスをリターンアドレスへ書き込むことでライブラリに飛ばすこともでき、その攻撃手段を ret2plt といいます。

```shell
pwndbg> got

GOT protection: Full RELRO | GOT functions: 3

[0x55a3cb9f2fc0] free@GLIBC_2.2.5 -> 0x7fda9a390740 (free) ◂— endbr64
[0x55a3cb9f2fc8] __stack_chk_fail@GLIBC_2.4 -> 0x7fda9a4213b0 (__stack_chk_fail) ◂— endbr64
[0x55a3cb9f2fd0] malloc@GLIBC_2.2.5 -> 0x7fda9a390130 (malloc) ◂— endbr64
```

### Return-Oriented Programming

リターンアドレスの書き換えを更に押し進めることで Return-Oriented Programming (ROP) となります。

ret 命令で終わる少ない命令列 (Gadget) が機械語の中にあるのでそれを return address の書き換えで呼び出す攻撃手法です。

呼び出す関数の引数がスタックを使用し、その後 2 つ以上の関数を呼ぶ場合は引数が Gadget と被らないように引数を削除する `pop ret` ガジェットを挟む。

また Gadget を見つける際に重宝するツールがあります。

https://github.com/david942j/one_gadget
https://github.com/JonathanSalwan/ROPgadget

```shell
$ ROPgadget --binary ./chall
Gadgets information
============================================================
0x000000000000121b : add byte ptr [rax], 0 ; add byte ptr [rax], al ; endbr64 ; jmp 0x11a0
0x0000000000001193 : add byte ptr [rax], 0 ; add byte ptr [rax], al ; ret
0x000000000000121c : add byte ptr [rax], al ; add byte ptr [rax], al ; endbr64 ; jmp 0x11a0
0x00000000000014cc : add byte ptr [rax], al ; add byte ptr [rax], al ; endbr64 ; ret
0x0000000000001194 : add byte ptr [rax], al ; add byte ptr [rax], al ; ret
0x0000000000001036 : add byte ptr [rax], al ; add dl, dh ; jmp 0x1020
0x0000000000001210 : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax] ; ret
0x000000000000121e : add byte ptr [rax], al ; endbr64 ; jmp 0x11a0
0x00000000000014ce : add byte ptr [rax], al ; endbr64 ; ret
0x00000000000013f6 : add byte ptr [rax], al ; mov eax, dword ptr [rbp - 4] ; leave ; ret
0x0000000000001386 : add byte ptr [rax], al ; pop rbp ; ret
0x0000000000001196 : add byte ptr [rax], al ; ret
0x000000000000100d : add byte ptr [rax], al ; test rax, rax ; je 0x1016 ; call rax
0x0000000000001188 : add byte ptr [rax], al ; test rax, rax ; je 0x1198 ; jmp rax
0x00000000000011c9 : add byte ptr [rax], al ; test rax, rax ; je 0x11d8 ; jmp rax
0x00000000000011d5 : add byte ptr [rax], r8b ; ret
0x0000000000001211 : add byte ptr [rcx], al ; pop rbp ; ret
0x00000000000013c3 : add byte ptr [rdi + 7], bh ; mov eax, 0xffffffff ; jmp 0x13fb
0x0000000000001187 : add byte ptr cs:[rax], al ; test rax, rax ; je 0x1198 ; jmp rax
0x00000000000011c8 : add byte ptr cs:[rax], al ; test rax, rax ; je 0x11d8 ; jmp rax
0x0000000000001038 : add dl, dh ; jmp 0x1020
0x0000000000001212 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax] ; ret
0x0000000000001085 : add eax, 0xf2000000 ; jmp 0x1020
0x0000000000001453 : add eax, 0xfffc87e8 ; dec ecx ; ret
0x00000000000013f3 : add eax, edx ; mov byte ptr [rax], 0 ; mov eax, dword ptr [rbp - 4] ; leave ; ret
0x0000000000001017 : add esp, 8 ; ret
0x0000000000001016 : add rsp, 8 ; ret
0x00000000000011c7 : and eax, 0x4800002e ; test eax, eax ; je 0x11d8 ; jmp rax
0x000000000000103e : call qword ptr [rax - 0x5e1f00d]
0x0000000000001014 : call rax
0x00000000000013c2 : cld ; add byte ptr [rdi + 7], bh ; mov eax, 0xffffffff ; jmp 0x13fb
0x00000000000013fa : cld ; leave ; ret
0x0000000000001223 : cli ; jmp 0x11a0
0x00000000000014d3 : cli ; ret
0x00000000000014db : cli ; sub rsp, 8 ; add rsp, 8 ; ret
0x0000000000001362 : dec ecx ; ret
0x0000000000001220 : endbr64 ; jmp 0x11a0
0x00000000000014d0 : endbr64 ; ret
0x00000000000014ac : fisttp word ptr [rax - 0x7d] ; ret
0x000000000000100b : fldcw word ptr [rdi] ; add byte ptr [rax], al ; test rax, rax ; je 0x1016 ; call rax
0x0000000000001012 : je 0x1016 ; call rax
0x000000000000118d : je 0x1198 ; jmp rax
0x00000000000011ce : je 0x11d8 ; jmp rax
0x00000000000013c4 : jg 0x13cd ; mov eax, 0xffffffff ; jmp 0x13fb
0x000000000000103a : jmp 0x1020
0x0000000000001224 : jmp 0x11a0
0x0000000000001339 : jmp 0x12a2
0x00000000000012ca : jmp 0x1323
0x000000000000128e : jmp 0x1363
0x00000000000013cb : jmp 0x13fb
0x0000000000001441 : jmp 0x143f
0x000000000000118f : jmp rax
0x0000000000001384 : jne 0x1386 ; add byte ptr [rax], al ; pop rbp ; ret
0x0000000000001363 : leave ; ret
0x00000000000011d1 : loopne 0x1239 ; nop dword ptr [rax + rax] ; ret
0x00000000000013f5 : mov byte ptr [rax], 0 ; mov eax, dword ptr [rbp - 4] ; leave ; ret
0x000000000000120c : mov byte ptr [rip + 0x2dfd], 1 ; pop rbp ; ret
0x0000000000001289 : mov eax, 0xffffffff ; jmp 0x1363
0x00000000000013c6 : mov eax, 0xffffffff ; jmp 0x13fb
0x00000000000013f8 : mov eax, dword ptr [rbp - 4] ; leave ; ret
0x00000000000011d3 : nop dword ptr [rax + rax] ; ret
0x0000000000001191 : nop dword ptr [rax] ; ret
0x00000000000011d2 : nop word ptr [rax + rax] ; ret
0x00000000000011cf : or bh, bh ; loopne 0x1239 ; nop dword ptr [rax + rax] ; ret
0x00000000000014bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000000014be : pop r13 ; pop r14 ; pop r15 ; ret
0x00000000000014c0 : pop r14 ; pop r15 ; ret
0x00000000000014c2 : pop r15 ; ret
0x00000000000014bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000000014bf : pop rbp ; pop r14 ; pop r15 ; ret
0x0000000000001213 : pop rbp ; ret
0x00000000000014c3 : pop rdi ; ret
0x00000000000014c1 : pop rsi ; pop r15 ; ret
0x00000000000014bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x000000000000101a : ret
0x000000000000131f : retf 0x1088
0x00000000000013f4 : rol dh, 1 ; add byte ptr [rax], al ; mov eax, dword ptr [rbp - 4] ; leave ; ret
0x0000000000001011 : sal byte ptr [rdx + rax - 1], 0xd0 ; add rsp, 8 ; ret
0x000000000000105b : sar edi, 0xff ; call qword ptr [rax - 0x5e1f00d]
0x000000000000120e : std ; sub eax, 0x5d010000 ; ret
0x000000000000120f : sub eax, 0x5d010000 ; ret
0x00000000000014dd : sub esp, 8 ; add rsp, 8 ; ret
0x00000000000014dc : sub rsp, 8 ; add rsp, 8 ; ret
0x0000000000001010 : test eax, eax ; je 0x1016 ; call rax
0x000000000000118b : test eax, eax ; je 0x1198 ; jmp rax
0x00000000000011cc : test eax, eax ; je 0x11d8 ; jmp rax
0x000000000000100f : test rax, rax ; je 0x1016 ; call rax
0x000000000000118a : test rax, rax ; je 0x1198 ; jmp rax
0x00000000000011cb : test rax, rax ; je 0x11d8 ; jmp rax

Unique gadgets found: 89

$ one_gadget ./libc.so.6
0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

0x4f322 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a38c execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
```

## セキュリティ機構

スタック領域やプロセス全体として NX, ASLR, RELRO, PIE, Stack Canary などのセキュリティ機構 (Mitigations) があります。

これらを ELF ファイルから調べてくれる checksec というスクリプトがあります。pwndbg の `checksec` コマンドもエイリアスとしてあります。

https://github.com/slimm609/checksec.sh

```shell
$ checksec --file=a.out
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable   FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   38) Symbols       No    0               0    a.out
```

### Stack Canary

関数呼び出し時に return address の次に Master Canary から得られるランダムな値 (Canary) を配置し、return 前に Canary が変化したか `__stack_chk_fail` 関数を呼び出して検証し、変わっていたら例外を送出します。これによって連続的に書き込む BOF を検知することができます。

これを回避して BOF するには Canary を読み出したり、 1 バイトずつブルートフォースすることで Canary を手に入れて BOF 時に書き込めば検査にひっかかりません。

また Master Canary は TLS (Thread Local Storage) に格納されています。(x86-64 では fs:0x28)
これ自体を書き換えるという攻撃手法を Master Canary Forging といいます。potetisensei の解説を載せておきます。

https://www.youtube.com/watch?v=UTC2iWxQ4qc

### No eXecute bit
No eXecute bit (NX bit) は読み書きのフラグの他に CPU が特定のセグメントを実行できないようにするフラグを追加します。ソフトウェア上で W^X (Write xor Execute) が成り立つようにフラグを立てることで shellcode が難しくなりました。

これを回避して shellcode を実行するには RWX のメモリ領域を作成する必要があります。これは ret2plt や ret2libc によって `mmap()` `mprotect()` を呼び出すことで作れるので回避できます。

### RELRO
glibc などの動的ライブラリをリンクするとき、lazy binding といってシンボル名の検索とアドレスの解決については呼び出し時まで遅延させてプログラムの起動を早めます。ただ GOT overwrite に対して起動時に全て行い、書き込み禁止とするのが RELRO (RELocation Read-Only) です。

|  | lazy binding | RELRO |
| --- | --- | --- |
| No RELRO | Yes | No |
| Partial RELRO | Yes | Yes |
| Full RELRO | No | Yes |

### ASLR & PIE
Address Space Layout Randomization (ASLR) はスタックやヒープ、動的ライブラリが置かれるベースアドレスをランダム化する機構です。

プロセス起動時にページ単位 (0x1000) で仮想アドレスの対応がされます。

```
$ cat /proc/<pid>/maps
```

Position-Independent Executables (PIE) は .text 領域のアドレスもランダム化する機構です。jump や call は全て相対アドレス指定となります。

ASLR & PIE によって exploit が一段階難しくなりました。

ただ依然として相対的にはアドレスは同じであるため、例えば次のようにしてベースアドレスを取得することができます。

- スタックに積まれたリターンアドレスの値から、.text 領域のベースアドレスが計算できる。これを .text 領域が分かると .data .bss .plt .got.plt などのベースアドレスも色々わかる。
- 一度呼び出されたライブラリ関数の GOT アドレスの値から、そのライブラリのベースアドレスが計算できる。
- スタックに積まれたsaved ebpの値から、スタック領域に置かれる他のデータのアドレスが計算できる。
- ヒープ領域に確保されたデータを指すポインタの値から、ヒープ領域のベースアドレスが計算できる。

特に libc のベースアドレスを求めることは大変重要で、 libc leak といいます。libc leak できると例えばライブラリを呼び出したり (ret2libc)、文字列 `/bin/sh` も libc 内にあるのでシェル起動が簡単になります。

```python
from pwn import *

libc = ELF('libc.so')
system_offset = libc.symbols['system']
sh_offset = next(libc.search('sh\x00'))
binsh_offset = next(libc.search('/bin/sh\x00'))
```

### ASCII-armor

共有ライブラリのベースアドレスを `0x00XXXXXX` のように `\x00` を含めることで BOF によって書き込むことを難しくする機構です。

### Control Flow Integrity

ROP, JOP 対策として導入された主に CPU のセキュリティ機構です。Intel, ARM, RISC-V における CFI (Control Flow Integrity) 拡張をまとめます。

- Intel CET Shadow Stack
  - call 命令で return address を shadow stack に push し、ret 命令で pop して一致しなければ例外を送出する。既存のコードを変更せずに適用できるのが強み。
- Intel CET Indirect Branch Tracking (IBT)
  - jump 先に endbranch 命令を埋め込み、関数ポインタの先が endbranch 命令を指していない場合には例外が送出される機構。JOP の検知ができる。
- ARM Branch Target Identification (BTI)
  - br/blr 命令によって jump した先が bti 命令以外であれば例外を送出する機構。PTE の GP ビットが立っているときにそのアドレス範囲での BTI が有効になる。JOP の検知ができる。
- ARM Pointer Authentication (PAC)
  - PAC 命令で 64 bit ポインタの上位 8 bit にタグ, 3-23 bit にアドレスの署名を埋め込み、AUTH 命令で認証し、無効な署名を持つ場合に例外が送出される機構。署名は QARMA アルゴリズムが推奨されている。ROP の検知ができる。
- ARM Memory Tagging Extension (MTE)
  - メモリにタグを割り当て、ポインタの上位 4 bit にタグを埋め込み、アクセス時にそれらが不一致の場合には例外が送出される機構。Use After Free の検知ができる。
- RISC-V CFI Shadow Stack
  - 特殊なメモリ領域に Shadow Stack を確保し、return address のみの読み書きをする。sspush, sspop, sschkra 命令によって return address のプッシュ、ポップ、比較をし、不一致ならば例外を送出する。
- RISC-V CFI Landing Pads
  - 新しい命令 lpsll, lpcll 命令を追加して jalr 命令の分岐前と分岐後で label を照合することで想定された組み合わせかどうかを判定し、不一致なら例外を送出する。デメリットとしてツールチェイン側が実装する際にバグが発生しそうなことが挙げられる。

これらによって ROP は不可能になったといってもいいでしょう。

CFI をソフトウェアで実装することもあるのですがこれに関しては様々な脆弱性が見つかっているのでそこを攻撃することは可能です。

## ツール
ローカルで実行バイナリを動かして解析したいときデバッガーが重宝します。ELF のデファクトスタンダードなデバッガーは gdb で、使い方は他の記事を参考にしてください。

また、gdb に拡張的な機能を与えるプラグインも開発されていて、現在、主要なプラグインは次のようなものです。全部セットで入れられるインストーラーもあります。

- gdb-peda
- pwndbg (コマンドが豊富でおすすめ)
- gef

https://github.com/apogiatzis/gdb-peda-pwndbg-gef

大抵の問題は `nc` コマンドでサーバーに接続してバイナリが実行されるような形式で主題され、実行バイナリやソースコードも配られることもあります。この通信を簡単に取り扱いたい、またバイナリを解析したいというモチベーションで作られた pwntools、そしてそれを改良した ptrlib という Python のパッケージがあります。このような便利なパッケージが多く、言語は Python が選ばれやすいです。

https://github.com/Gallopsled/pwntools
https://github.com/ptr-yudai/ptrlib

pwn で私がいつも使っている Python のテンプレートです。

```python
from pwn import *
import sys

binary_path = './chall'

if len(sys.argv) == 3:
    io = remote(sys.argv[1], int(sys.argv[2]))
else:
    io = process(binary_path)
elf = ELF(binary_path)
# libc = ELF("./libc.so.6")

def wait_for_attach():
    print('attach?')
    raw_input()

payload = b''
io.sendlineafter(b'> ', payload)
io.recvline()
io.interactive()
```

# まとめ
スタック領域に関する exploit は pwn の begginer / easy レベルに当たるので解けるようになると初心者脱却できると思います。

次はヒープ領域に関する exploit です。少し難しいですが基本的にはここでやった考え方と同じなのでよく理解して挑んでください。
