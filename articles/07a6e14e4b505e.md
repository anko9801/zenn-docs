---
title: "Type challenge ã«å¿…è¦ãªçŸ¥è­˜"
emoji: "ğŸ“Œ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["TypeScript"]
published: false
---

## å‹

### ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹

```ts
string
number
bool
function
interface User {
    name: string;
    age: number;
    private: boolean;
}
type User = {
    name: string;
    age: number;
    private: boolean;
};
type IsPositiveFunc = (arg: number) => boolean;
interface IsPositiveFunc {
  (arg: number): boolean;
}
```

ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã¯ key, value ã§æ§‹æˆã•ã‚Œã€é…åˆ—ã¯ key ãŒ number ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã¨ã„ãˆã‚‹ã€‚

```ts
T[]
[]
[...T[]]
```

Keyof Type Operator
Indexed Access Types ã¯æ¬¡ã®æ€§è³ªã‚’æŒã¡ã¾ã™ã€‚
`...` ã¯ã‚¿ãƒ—ãƒ«å†…ã§1å›ã—ã‹ä½¿ãˆãªã„

```ts
K1 | ... | Kn = keyof T
T[K1] | ... | T[Kn] = T[K1 | ... | Kn]
T[0] | ... | T[n] = T[number]
```

### Conditional Types

```ts
T extends U ? X : Y
```

### Mapped Types

`NewKeyType` ã§ã¯ `never` ã¨ã™ã‚‹ã“ã¨ã§ãã®ã‚«ãƒ©ãƒ ã‚’æ¶ˆã™ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚é€†ã«å¢—ã‚„ã™æ–¹æ³•ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚

```ts
type MappedTypeWithNewProperties<Type> = {
  [Property in keyof Type as NewKeyType]: Type[Properties];
};
{ [P in T]: K<P> };
interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
```

### Template Literal Types

```ts
infer
```

ç¶™æ‰¿é–¢ä¿‚ã¨ãªã‚‹

### å†å¸°æ§‹é€ 

æ¬¡ã®ã‚ˆã†ã«å†å¸°æ§‹é€ ã¯æ›¸ãã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã¯ä¸å¯èƒ½ã¨ãªã‚‹æ¡ä»¶ãŒé›£ã—ã„ã®ã§å®Ÿè£…ã•ã‚Œã¦ãªã„ã‚ˆã†ã§ã™ã€‚

```ts
type A = T<A>
type A = A[]

// NG
type Data = number | string | Data[] | Record<string, Data>;
// OK
type Data = number | string | { [key: number]: Data } | { [key: string]: Data };
```


```ts
type Getters<Type> = {
    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
};
type First<T extends any[]> = T extends [] ? never : T[0];
type Partial<T> = { [P in keyof T]?: T[P] | undefined; }
type Required<T> = { [P in keyof T]-?: T[P]; }
type Readonly<T> = { readonly [K in keyof T]: T[K] };
type Readonly2<T, K extends keyof T = keyof T> = { readonly [k in K]: T[k] } & Omit<T, K>;
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends Record<string, unknown> | Array<unknown>
    ? DeepReadonly<T[K]>
    : T[K];
};
type Record<K extends string | number | symbol, T> = { [P in K]: T; }
type Extract<T, U> = T extends U ? T : never
type Exclude<T, U> = T extends U ? never : T
type NonNullable<T> = T & {}
type Pick<T, K extends keyof T> = { [key in K]: T[key] };
type Omit<T, K extends keyof T> = { [key in keyof T as key extends K ? never : key]: T[key]; };
type TupleToUnion<T extends any[]> = T[number];
type TupleToObject<T extends readonly any[]> = { [K in T[number]]: K };
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : never
type InstanceType<T extends abstract new (...args: any) => any> = T extends abstract new (...args: any) => infer R ? R : any
type ConstructorParameters<T extends abstract new (...args: any) => any> = T extends abstract new (...args: infer P) => any ? P : never
type ThisParameterType<T> = T extends (this: infer U, ...args: never) => any ? U : unknown
type OmitThisParameter<T> = unknown extends ThisParameterType<T> ? T : T extends (...args: infer A) => infer R ? (...args: A) => R : T
```
