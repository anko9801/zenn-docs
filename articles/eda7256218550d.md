---
title: "【pwn ノート】Stack Exploit 編"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["CTF", "pwn"]
published: false
---

Stack 領域に関する攻撃

https://zenn.dev/anko/articles/3f8fa3fc559930

実行アドレスを書き換える
Stack Heap

ABI

| arch | 返り値 | 1 | 2 | 3 | 4 | 5 | 6 | syscall |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| x86-64 | rax | rdi | rsi | rdx | r10 | r8 | r9 | rax |

## スタック領域における書き換え手段

### Buffer Overflow
通称 BOF

`char buf[40]` と `char buf2[60]` を宣言して次の関数を考える。

| 関数 | 挙動 | 安全性 |
| --- | --- | :-: |
| `scanf("%s", buf)` | 境界チェックせずに入力する。 | pwnable |
| `scanf("%39s", buf)` | 39 バイト入力した後に NULL バイトを置く。 | safe |
| `scanf("%40s", buf)` | 40 バイト入力した後に NULL バイトを置く。 | pwnable |
| `gets(buf)` | 境界チェックせずに入力する。 | pwnable |
| `fgets(buf, 40, stdin)` | 39 バイト入力した後に NULL バイトを置く。 | safe |
| `read(stdin, buf, 40)` | 40 バイト入力した後に NULL バイトを置かない。 | leakable |
| `fread(buf, 1, 40, stdout)` | 40 バイト入力した後に NULL バイトを置かない。 | leakable |
| `strcpy(buf, buf2)` | 境界チェックせずに文字列をコピーする。 | pwnable |
| `strncpy(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `memcpy(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `memmove(buf, buf2, 40)` | 40 バイトコピーした後に NULL バイトを置かない。 | leakable |
| `strcat(buf, buf2)` | 境界チェックせずに文字列を `buf` に連結する。 | pwnable |
| `strncat(buf, buf2, 10)` | 10 バイト連結した後に NULL バイトを置かない。 | pwnable |
| `sprintf(buf, format, ...)` | 書式を適用した文字列を境界チェックせずに入力した後に NULL バイトを置く。 | pwnable |
| `snprintf(buf, 40, format, ...)` | 書式を適用した文字列を 39 バイト入力した後に NULL バイトを置く。 | safe |

境界チェックとは配列に書き込む前にインデックスが正当な位置にあるかどうかを検査することです。
ちなみに NULL の 1 バイトだけ BOF できることは一見 exploit に繋がらなさそうに見えます。しかしアドレスの下位 1 バイトを 0x00 に書き換えて、アドレスの指す位置を若干ずらすことができます。

```c
int main() {

}
```

### Format String Bug

`printf` 関数の第一引数は書式 (Format String) といい、`%` から始まるプレースホルダーによって引数に対して文字列処理を行い、埋め込みます。

```c
%[parameter][flags][width][.precision][length]type
```

| フィールド | 具体例 | 説明 |
| --- | --- | --- |
| parameter | `6$` | 第二引数以降の引数の番号を表す。通常、書式が呼ばれる度インクリメントされるがこれによって一気に飛ばすことが出来る。x86-64 では 6 以降はスタックを指す。 |
| width | `40` `*` | 出力するバイト長を表す。 |
| length | `hh` `h` `l` | 入力する長さを表す。具体例はそれぞれ 1, 2, 8 バイトを表している。 |
| type | `d` `x` `p` `s` `n` ... | データをどのように解釈するかや書き込みなどを表す。 |

https://en.wikipedia.org/wiki/Printf#Format_placeholder_specification

例えば次のような例があります。

- `%42x` は unsigned int を 16 進数として 42 文字出力する。余った文字は空白となる。
- `%6$p` は第 7 引数、つまりスタック上の値をポインタとして出力する。
- `%s` は引数のアドレスから文字列として NULL バイトまで出力する。
- `%hhn` は引数のアドレスにこれまで出力した文字数を 1 バイト書き込む。Overflow するので一周すれば任意の値を書き込める。

```c
int main() {
    int value = 42;
    char buf[40];
    fgets(buf, 40, stdin);
    printf(buf);
    puts(value);
}
```

## スタック領域における攻撃方法

### リターンアドレスの書き換え

[単純なスタックバッファオーバーフロー攻撃をやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/03/14/151011)

### シェルコード

機械語 (shellcode) をスタック上に埋め込み、rip をそこに飛ばす。スタックアドレスが分かっている必要がある。

- `system("/bin/sh")`
- `execve("/bin/sh", 0, 0)`
- `open("flag") -> read() -> write()`
  - chroot 環境で `/bin/sh` がなかったり、seccomp によってシステムコールを制限されているときに使う。

アセンブリから機械語へ変換する必要があるのでアセンブラに通したり、規格書にまとまった情報があります。

- [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
- [図式された x86 の命令集](https://hikalium.github.io/opv86/)
- [ARM Architecture Reference Manual](https://documentation-service.arm.com/static/5f8dacc8f86e16515cdb865a)
- [The RISC-V Instruction Set Manual](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf)

### GOT overwrite

GOT を書き換えることで libc の関数を呼び出したときに rip を奪取できる。

Full RELRO によって対策される。

[Format String AttackによるGOT overwrite(2020/05/02) - いい感じに生きる](https://sok1.hatenablog.com/entry/2022/01/17/050556)

## セキュリティ機構

### Stack-Smashing Protection

関数呼び出し時に return address の次に Master Canary から得られるランダムな値 (Canary) を配置し、return 前に Canary が変化したか検証し、変わっていたら`__stack_chk_fail` 関数を呼び出して例外を送出する。



https://www.youtube.com/watch?v=UTC2iWxQ4qc

### DEP (Data Execution Prevention)

- NX bit (No eXecute bit) read write execute protection
- セグメント毎に実行する権限を付与するかしないかを設定する。任意のコードを挿入し実行を誘う攻撃を防御できる。
- メモリ領域のアクセス保護オプションを書き換えるには、Windowsの場合VirtualProtectEx関数、Linuxの場合mprotect(2)が使える。

[Return-to-libcとmprotect(2)でDEPを回避してみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/04/20/010545)

### RELRO (RELocation Read-Only)

GOT

- 初回呼び出し時に書き込む、遅延バインド (lazy binding)

GOT overwrite 対策 RELRO

- 遅延バインドせず、最初に書き込み、あとは書き込み不可とする

|  | lazy binding | RELRO |
| --- | --- | --- |
| No RELRO | Yes | No |
| Partial RELRO | Yes | Yes |
| Full RELRO | No | Yes |

[RELROとformat string attackによるリターンアドレス書き換え - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/04/30/173618)

### ASLR (Address Space Layout Randomization)

Stack / Heap 領域や共有ライブラリが置かれるベースアドレスをランダムに決められる。これらのアドレスを知るには以下のコマンドを叩く。一回目と二回目で変わることが分かる。

```
$ cat /proc/<process ID>/maps              // = gdbのi proc map = pwndbgのvmmap
```

[ブルートフォースによる32bit ASLR回避 - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/03/15/073837)

### PIE (Position-Independent Executables)

実行ファイルそのものが置かれるベースアドレスをランダムに決められる。

1nibble brute force

### ASCII-armor / Exec-Shield

共有ライブラリのベースアドレスを `0x00XXXXXX` のように `\x00` を含めることで libc leak させないようにする機構。

### Control Flow Integrity

ROP, JOP 対策として導入された CPU のセキュリティ機構。Intel, ARM, RISC-V における CFI (Control Flow Integrity) 拡張をまとめる。

- Intel CET Shadow Stack
    - call 命令で return address を shadow stack に push し、ret 命令で pop して一致しなければ例外を送出する。既存のコードを変更せずに適用できるのが強み。
- Intel CET Indirect Branch Tracking (IBT)
    - jump 先に endbranch 命令を埋め込み、関数ポインタの先が endbranch 命令を指していない場合には例外が送出される機構。JOP の検知ができる。
- ARM Branch Target Identification (BTI)
    - br/blr 命令によって jump した先が bti 命令以外であれば例外を送出する機構。PTE の GP ビットが立っているときにそのアドレス範囲での BTI が有効になる。JOP の検知ができる。
- ARM Pointer Authentication (PAC)
    - PAC 命令で 64 bit ポインタの上位 8 bit にタグ, 3-23 bit にアドレスの署名を埋め込み、AUTH 命令で認証し、無効な署名を持つ場合に例外が送出される機構。署名は QARMA アルゴリズムが推奨されている。ROP の検知ができる。
- ARM Memory Tagging Extension (MTE)
    - メモリにタグを割り当て、ポインタの上位 4 bit にタグを埋め込み、アクセス時にそれらが不一致の場合には例外が送出される機構。Use After Free の検知ができる。
- RISC-V CFI Shadow Stack
    - 特殊なメモリ領域に Shadow Stack を確保し、return address のみの読み書きをする。sspush, sspop, sschkra 命令によって return address のプッシュ、ポップ、比較をし、不一致ならば例外を送出する。
- RISC-V CFI Landing Pads
    - jalr 命令を拡張して間接分岐の直後は 4-byte aligned な lpcll (Landing Pads: Check Lower Label) 命令しか実行できないようにする。分岐元と分岐先で Label を照合することで想定された組み合わせかどうかを判定し return address overwrite で有効なアドレスを十分に減らす。Label は
    次のような命令でセットすることができる。
        - 9-bit: LPSLL 命令
        - 17-bit: LPSLL + LPSML 命令
        - 25-bit: LPSLL + LPSML + LPSUL 命令
    - デメリットとしてはツールチェイン側が実装する際にバグが発生しそうなことが挙げられる。

## セキュリティ機構のバイパス

### libc leak

ASLR + PIE によって Stack, Heap, libc, 命令列などのベースアドレスがランダム化される。

関数・データ間のオフセットは同じであるため、例えば次のようにしてベースアドレスを取得できる。

- スタックに積まれたリターンアドレスの値から、実行ファイルのベースアドレスが計算できる。
- 一度呼び出されたライブラリ関数のGOTアドレスの値から、そのライブラリのベースアドレスが計算できる。(libc leak)
- スタックに積まれたsaved ebpの値から、スタック領域に置かれる他のデータのアドレスが計算できる。
- ヒープ領域に確保されたデータを指すポインタの値から、ヒープ領域のベースアドレスが計算できる。

対抗策

- ライブラリ内のsystem関数ではなくsystem@pltに飛ばす(ret2plt)。
- system@pltがなければstrcpy@pltやsnprintf@pltに飛ばして(ret2strcpy)、実行バイナリ中の1バイトで1つずつGOT overwriteし、シェルを起動する。

`__libc_system` のアドレスを求める。

ret2libc

stack underflow 関数フレーム外までpopを行う。

ret2plt

ret2csu


### ROP; Return-Oriented Programming

ret 命令で終わる少ない命令列 (Gadget) が機械語の中にある。
NX bit

```nasm
; gadget 1
pop rdi
ret
; gadget 2
pop rsi
ret
; gadget 3
pop rdx
ret
; gadget 4
pop rax
ret
; gadget 5
syscall
ret
```

Shellcode なしでレジスタに値を書き込めるようになった。

呼び出し規約がcdeclなどスタックを用いる場合

3つ以上の関数を呼ぶとき引数が関数アドレスと被らないように引数を削除する為の pop ret ガジェットを挟む。