---
title: "公開鍵暗号"
---

ここでは公開鍵暗号やその周辺を理解するだけで攻撃はしないので攻撃したい人はさらっと読み飛ばすといいかも。

## 公開鍵暗号
公開鍵暗号は次のようなものでした。

> **公開鍵暗号**
> 暗号化と復号で **別の鍵** を使い、暗号化で使う鍵を **公開** する方式
> ex.) RSA暗号, 楕円曲線暗号 など

暗号化と復号が別の鍵？そんなこと言われてもよくわからないよ！ボケ！となると思うので、最も有名な公開鍵暗号である RSA 暗号を紹介しましょう。

RSA 暗号とは $N$ で割った余りの世界において $e$ 乗で暗号化、 $e^{-1}$ 乗で復号する暗号です。

$$
\begin{aligned}
c &= m^e & \pmod N \\
m &= c^{e^{-1}} & \pmod N
\end{aligned}
$$

例えば平文 $m = 5$ として $(e, N) = (3, 11)$ とすると $5^3 = 125$ は 11 で割ると 4 余ります。これより暗号化すると

$$
m^e = 5^3 = 125 = 4 \pmod{11}
$$

となります。逆に復号は $e^{-1} = 7$ なので

$$
c^{e^{-1}} = 4^7 = 16384 = 5 \pmod{11}
$$

とこのように平文と一致するので暗号として成り立っていそうです。(暗号文も単なる数字で暗号っぽくないのは小さい数で)

これを元に手順と Python での実装をサラっと書くと次のようになります。

> **RSA 暗号 (Rivest-Shamir-Adleman encryption)**
> - 鍵生成
>   1. 大きな素数 $p, q$ を生成して $N = pq$ と $\phi(N) = (p - 1)(q - 1)$ を計算する。
>   2. 整数 $e$ を決めて $d = e^{-1} \pmod{\phi(N)}$ を計算する。
>   3. $N, e$ を公開鍵として相手に渡し、$p, q, \phi(N), d$ を秘密鍵とする。
> - 暗号化
>   渡された公開鍵を用いて平文 $m$ に対して $c = m^e \bmod N$ と暗号化し、相手に送る。
> - 復号
>   持っている秘密鍵を用いて暗号文 $c$ に対して $m = c^d \bmod N$ と復号する。

```python
from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long

p = getPrime(512)
q = getPrime(512)
N = p * q
phi = (p - 1) * (q - 1)
e = 0x10001
d = pow(e, -1, phi)

def encrypt(plaintext):
    m = bytes_to_long(plaintext)
    c = pow(m, e, N)
    cipher = long_to_bytes(c)
    return cipher

def decrypt(cipher):
    c = bytes_to_long(cipher)
    m = pow(c, d, phi)
    plaintext = long_to_bytes(m)
    return plaintext

cipher = encrypt(b"This is RSA")
print(cipher)
plaintext = decrypt(cipher)
print(plaintext)
# This is RSA
```

お、出てきましたよ鍵が！(倒置法) この公開鍵と秘密鍵がそれぞれ暗号化する鍵と復号する鍵に対応します。
本当でしょうか？確かめてみましょう！

**公開鍵で暗号化**
まず公開鍵 $e, N$ で暗号化することはできるでしょうか。

$$
c = m^e \pmod N
$$

これはちゃんと秘密鍵を使わずにできますね。

**秘密鍵で復号**
それじゃ秘密鍵で復号することができるでしょうか。

$$
m = c^d \pmod N
$$

秘密鍵 $d$ を使って復号していますね。ただ $N$ も使っているので公開鍵も必要そうです。これは秘密鍵から公開鍵は $N = pq, e = d^{-1}\bmod \phi$ と計算できるので大丈夫です。

**公開鍵で復号**
それでは逆に公開鍵で復号できるでしょうか。これが出来てしまうと暗号として機能していないと言えます。復号する為には公開鍵から秘密鍵 $d$ を求められればよいです。$d$ を求める為には $p, q$ が必要なので $N$ の素因数分解できると復号できてしまいます！このことを踏まえて RSA 暗号は素因数分解が出来ないくらい大きな数 $N$ を使います。実際によく使われる $N$ はだいたい $2^{1024} \approx 10^{400}$ でとっても大きな数です。

**秘密鍵で暗号化**
最後に秘密鍵で暗号化できるでしょうか。前と同様に秘密鍵から公開鍵を計算できるので暗号化できます。

これらを表にまとめるとこんな感じです。

| | 自分 (公開鍵 + 秘密鍵) | 全員 (公開鍵) |
|:-:|:-:|:-:|
| 暗号化 | 可能 | 可能 |
| 復号 | 可能 | 不可能 |

このように公開鍵だけを公開することで自分以外の人は復号ができないので暗号化された通信が出来るわけです。

ここに図

さらに共通鍵暗号では復号できる鍵を渡す必要がありましたが、公開鍵暗号では一切他人に **復号する権限を渡しません**。これが公開鍵暗号の真髄です。これによりどこにも脆弱性のない原理的に **完全に安全な暗号** と言えます。

ただし、ここでは攻撃者の計算能力を考慮に入れずに素因数分解が解けないものとして扱いました。計算能力込みで暗号の安全性を考えるには情報理論が必要となるので詳細には話せませんが最後に解説したいと思います。

そして素因数分解問題の他にも離散対数問題という計算困難な問題が知られています。

> **素因数分解問題**
> ある桁数の大きい 2 つの素数の積である合成数 $N = pq$ が与えられたときに素数 $p, q$ を見つける問題。
> ex.) RSA 暗号, Paillier 暗号, Rabin 暗号

> **離散対数問題**
> 位数 $N$ が大きい巡回群 $G$ について $g, y\in G$ が与えられたときに $g^x = y$ となる最小の $x\in \mathbb{N}$ を求める問題。
> ex.) DH 鍵共有, DSA, ElGamal 暗号, 楕円曲線暗号

基本的にこれらの問題を安全性の根拠として公開鍵暗号が作られます。もちろん他にも公開鍵暗号で使われる問題はありますが、この 2 つだけでも現実で数え切れないほどたくさんの暗号があります。このシリーズで紹介するすべての公開鍵暗号のベースとなる問題はこれらのみなので名前だけでも覚えておきましょう！

## 公開鍵暗号の応用

公開鍵暗号の重要な役割の 1 つが共通鍵暗号で用いる鍵を誰にも知られずに共有することです。共通鍵暗号の一番のネックはそのまま鍵を共有すると盗聴されてしまうことでした。Diffie と Hellman が考えた画期的な鍵の共有方法を紹介します。

> **Diffie Hellman 鍵共有**
> 1. アリスとボブは巡回群 $G$ とその生成元 $g$ を共有する。
> 2. アリスとボブはそれぞれ秘密鍵 $x_a, x_b$ を生成し、公開鍵 $y_a = g^{x_a}, y_b = g^{x_b}$ を公開する。
> 3. 相手の公開鍵に自分の秘密鍵を掛けた $s$ はアリスとボブだけが知る共有鍵となる。
>
> $$
s = g^{x_ax_b} = y_b^{x_a} = y_a^{x_b}
$$

さらにハッシュ関数を噛ますこともある。


:::message
**練習問題**
$k$ がランダムであるかはかなり重要です。
Easy: $k = m$ かつ $p, q$ 固定のとき $m$ を取り出すことができる。どうやって？ (WaniCTF DSA?)
Hard: IP 偽装を署名を用いて防ぐことはできるでしょうか？
:::

## 離散対数問題
計算機で解くことの難しい部類 NP 完全の問題です。

> **離散対数問題 (DLP: Discrete Logarithm Problem)**
> 位数 $N$ の巡回群 $G$ について $g, y\in G$ が与えられるので $g^x = y$ となる最小の $x\in \mathbb{N}$ を求める問題。

- 有限体 $\mathbb{F}_p$ の DLP は FFDLP; Finite Field DLP と呼ばれる。巡回群 $\mathbb{F}_p$ の位数は $p-1$ となる。
- 楕円曲線 $E$ 上での DLP は ECDLP; Elliptic Curve DLP と呼ばれる。巡回群 $E/\mathbb{F}_p$ の位数は Hasse の定理より $|\#E/\mathbb{F}_p - (p+1)|\leq 2\sqrt{p}$ に制限される。

### Baby-step Giant-step

半分全列挙を用いる方法。

$m = \lceil\sqrt{N}\rceil$ とおく。DLP の解 $n$ を $m$ で割って $n = qm + r$ とおく。

$$
\begin{aligned}
y & = g^{qm + r} & (q, r\in[0, m-1])
\end{aligned}
$$

このとき $yg^{-r}$, $g^{qm}$ を全列挙し、どちらかのリストの要素をもう1つのリストで検索して $yg^{-r} = g^{qm}$ となる組を探索し、解を得る。この計算量は $O(\sqrt{N}\log N)$ でメモリも $O(\sqrt{N})$ だけ必要となります。つまり 64 ビット素数の DLP を解くには 2.2TB 必要となります。

### Pollard's $\rho$ 法

誕生日のパラドックスを用いる方法です。

> **Prop. 誕生日のパラドックス**
> 誕生日が同じ 2 人を見つけたいときに確率 $P$ を超えるには人を何人集めればよいのかという問題です。鳩ノ巣原理から $366$ 人いれば必ず同じ誕生日の人が出てきます。$50\%$ を超えるには $23$ 人で十分です。

**Proof.**
$N$ 種類の元から $k$ 個の元を取ってきたとき $k-1$ 個までそれぞれ相違なり, $k$ 個目で同じとなる確率は $t \ll 1$ のときの近似 $1 - t\approx e^{-t}$ を行うことで次のようになる。

$$
P(A) = \frac{k}{N}\prod_{i = 0}^{k-1}\left(1-\frac{i}{N}\right) \leq \frac{k}{N}\prod_{i = 0}^{k-1}e^{-i/N} = \frac{k}{N}e^{-k(k-1)/2N} \leq \frac{k}{N}e^{-k^2/2N}
$$

試行回数 $k$ に対する期待値は $t = k/\sqrt{N}$ と変数変換し、ガウス積分することで求まる。

$$
E(A) \leq \sum_{k=1}^N k\cdot\frac{k}{N}e^{-k^2/2N} = \sum_{k=1}^N t^2e^{-t^2/2} \leq \sqrt{N}\int_0^\infty t^2e^{-t^2/2}dt = \sqrt{\frac{\pi N}{2}}
$$

よって期待値は大体 $\sqrt{\frac{\pi N}{2}}$ となる為、$N = 365$ を代入すると 50\% を超えるには 23.95 人が必要となる。$\Box$

このように $N$ 種類のボールが入った袋から無作為に取ってきたら同じ種類のボールが 2 つ取れるような個数が $\mathcal{O}(\sqrt{N})$ であることを利用して計算量を落とすことを考えます。まず大枠としては次のようなアルゴリズムです。

1. 初期値 $a_0$ と決定的疑似乱数関数 $f$ を決めて数列 $a_{i+1} = f(a_i)$ を生成する。
2. $a_i = a_j$ となる $i, j\ (0\leq i<j<N)$ を発見する。
3. $a_i, a_j$ を用いて DLP を解く。

2 で見つけるのにだいたい $\mathcal{O}(\sqrt{N})$ 必要となるので数列を管理するのに平衡二分木を用いると計算量は $\mathcal{O}(\sqrt{N}\log N)$ となります。
図にすると次のような "$\rho$" の形になります。

![](/images/rho.png)

巡回群 $G$ 上の $y = g^x$ のもとで初期値 $a_0 = g$ とし、関数 $f$ については $G$ を $G_1, G_2, G_3$ に振り分けて次のように定義する。

$$
f(a)=
\begin{cases}
ya & (a \in G_1) \\
a^2 & (a \in G_2) \\
ga & (a \in G_3)
\end{cases}
$$

すると任意の生成元は $a_i = g^{s_i}y^{t_i} = g^{s_i + xt_i}\ (s_i, t_i \in \mathbb{N})$ と表される。ここで $a_i = a_j$ のとき

$$
\begin{aligned}
a_ia_j^{-1} & = g^{(s_i + xt_i) - (s_j + xt_j)} = 1 \\
x &= \frac{s_i - s_j}{t_j - t_i} & \pmod N
\end{aligned}
$$

となり $x$ が分かる。期待計算量は $\mathcal{O}(N^{1/4})$ です。

Pollard-$\rho$ 法の $\rho$ は文字 $\rho$ の形が $a_i$ の由来となっています。

### Pollard's Kangaroo 法 ($\lambda$ 法)
$\rho$ 法は動く点が1つの値だったのに対し、 $\lambda$ 法は2つの値がランダムに動いていき、一方がもう一方の点に衝突したとき DLP が解ける。

$$
\begin{aligned}
x_0 & = g^\alpha & y_0 & = y \\
x_{i+1} & = x_ig^{f(x_i)} & y_{i+1} & = y_ia^{f(y_i)} \\
\end{aligned}
$$

$x_i = y_j$ となるとき $x = \alpha + \sum_{k=1}^{i} f(x_k) - \sum_{k=1}^{j} f(y_k)$ となる。
見つからなければ $N$ や $f$ を取り替えて繰り返す。

同じく期待計算量は $\mathcal{O}(N^{1/4})$ です。

### Pohlig-Hellman

> **Prop.**
> 巡回群の位数が $|G| = \prod_{i = 1}^n p_i^{e_{i}}$ と素因数分解できるとき $G \cong \prod_{i = 1}^n \mathbb{Z}/p_i^{e_{i}}\mathbb{Z}$ となる。

アーベルの構造定理により証明できる。詳細は群論を学んでほしい。
これより中国剰余定理から $\mathcal{O}(\max{p_i^{e_i}})$ に落ちる。

### 指数計算法 (Index Calculus Algorithm)

因子基底 $p_j$
1. 小さな素因数 $p_j$ を用いて $yg^k = \prod_{j = 1}^m p_j^{e_{j}} \pmod p$ と書けるような $k$ を見つける。
2. $g^{k_i} = \prod_{j = 1}^m p_j^{e_{ij}} \pmod{p}$ と素因数分解できるような $k_i$ を $n$ 個以上見つける。

すると次のように書ける。

$$
\begin{aligned}
  g^{k_i} & = \prod_{j = 1}^m p_j^{e_{ij}} & \pmod p \\
  k_i & = \sum_{j = 1}^m e_{ij}\log_g{p_j} & \pmod{p-1} \\
\begin{pmatrix}
  k_1 \\
  \vdots \\
  k_n \\
\end{pmatrix} & =
\begin{pmatrix}
  e_{11} & \cdots & e_{m1} \\
  \vdots & \ddots & \vdots \\
  e_{1n} & \cdots & e_{mn}\\
\end{pmatrix}
\begin{pmatrix}
  \log_g p_1 \\
  \vdots \\
  \log_g p_m \\
\end{pmatrix} & \pmod{p-1}
\end{aligned}
$$

これよりガウスの消去法から $\log_g p_1, \ldots, \log_g p_n$ が求まる。よって次の式より $x$ が求まる。

$$
x = \sum_{j = 1}^me_j\log_g{p_j} - k \pmod {p-1}
$$

計算量は $\exp((\sqrt{2}+c)(\log n)^{1/2}(\log\log n)^{1/2})$ となる。

### 数体ふるい法




## まとめ
公開鍵暗号の基礎と応用の部分をやりました。暗号の中でもかなり不思議なものだったと思います。私も経験的に納得してるだけで直観的には納得しきれてません。なのでここで納得できてなくても大丈夫です。ここら辺は CTF をすれば咀嚼できるようになれると思います。

次はお待ちかね、CTF の中で最も出題されていると言っても過言ではない RSA 暗号への攻撃です！数学をかなり使うのでそれを補う「計算機代数」の章も参照しながらやっていくといいと思います。

## 参考文献
- https://www.zkdocs.com/
- [ZenGo-X/zk-paillier: A collection of Paillier cryptosystem zero knowledge proofs (github.com)](https://github.com/ZenGo-X/zk-paillier)
