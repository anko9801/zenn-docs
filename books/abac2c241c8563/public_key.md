---
title: "公開鍵暗号"
---

> **公開鍵暗号**
> 暗号化と復号で **別の鍵** を使い、暗号化で使う鍵を **公開** する方式
> ex.) RSA暗号, 楕円曲線暗号 など

- RSA 暗号
- 楕円曲線暗号

## 公開鍵暗号
暗号化と復号が別の鍵...と言われてもそんな暗号よくわからないと思うので最も有名な公開鍵暗号 RSA 暗号を紹介しましょう。

RSA 暗号とは $e$ 乗と $e^{-1}$ 乗を暗号化と復号の相互変換とした暗号です。

$$
\begin{aligned}
c &= m^e & \pmod N \\
m &= c^{e^{-1}} & \pmod N
\end{aligned}
$$

これを元に手順を書くと次のようになります。

> **RSA 暗号**
> - 鍵生成
>   1. 大きな素数 $p, q$ を生成して $N = pq$ と $\phi(N) = (p - 1)(q - 1)$ を計算する。
>   2. 整数 $e$ を決めて $d = e^{-1} \pmod{\phi(N)}$ を計算する。
>   3. $N, e$ を公開鍵として公開し、$p, q, \phi(N), d$ を秘密鍵とする。
> - 暗号化
>   1. 平文 $m$ に対して $c = m^e \bmod N$ と暗号化する。
> - 復号
>   1. 暗号文 $c$ に対して $m = c^d \bmod N$ と復号する。

これが RSA 暗号 (Rivest-Shamir-Adleman encryption) です。

ただ RSA 暗号は $N$ の素因数分解できると解かれてしまいます。

桁数の大きい 2 つの素数から構成される合成数の素因数分解問題や位数の大きい離散対数問題は困難であることが知られています。

> **素因数分解問題**
> ある合成数 $N$ が与えられたときに素数 $p_i$ と整数 $e_i$ を用いて $N = p_1^{e_1}\cdots p_n^{e_n}$ と素因数分解する問題。

> **離散対数問題**
> 位数 $N$ の巡回群 $G$ について $g, y\in G$ が与えられたときに $g^x = y$ となる最小の $x\in \mathbb{N}$ を求める問題。

trap-door function

公開鍵暗号の重要な役割の 1 つが共通鍵暗号で用いる鍵を誰にも知られずに共有することです。

共通鍵暗号の一番のネックはそのまま鍵を共有すると盗聴されてしまうことでした。Diffie と Hellman が考えた鍵の共有方法を紹介します。

> **Diffie Hellman 鍵共有**
> 1. アリスとボブは巡回群 $G$ とその生成元 $g$ を共有する。
> 2. アリスとボブはそれぞれ秘密鍵 $x_a, x_b$ を生成し、公開鍵 $y_a = g^{x_a}, y_b = g^{x_b}$ を公開する。
> 3. 相手の公開鍵に自分の秘密鍵を掛けた $s$ はアリスとボブだけが知る共有鍵となる。
>
> $$
s = g^{x_ax_b} = y_b^{x_a} = y_a^{x_b}
$$

ECDH だと $s$ の $x$ 座標をハッシュ化したものを共有鍵として使う。

### 電子署名
署名の方法にはいろいろありますが、暗号のレイヤーを抽象化すると

> **DSA; Digital Signature Algorithm**
> - 鍵生成
>   1. $p = 2q + 1$ となる素数 $p, q$ を生成すると $\mathbb{F}_p^\times \cong \mathbb{F}_q\times\mathbb{F}_2$ となる。
>   2. $g\in\mathbb{F}_p$ と $x\in\mathbb{F}_q$ を生成して $y = g^x \bmod p$ を計算する。
> - 署名
>   1. ランダムに $k$ を生成する。
>   2. $r = (g^k\bmod p)\bmod q$ と $s = k^{-1}(H(m) + xr) \bmod q$ を署名として公開する。
> - 検証
>   1. $v = (g^{s^{-1}H(m)}y^{s^{-1}r} \bmod p)\bmod q$ を計算して $r = v$ なら正当な署名となる。

:::message
**練習問題**
$k$ がランダムであるかはかなり重要です。
Easy: $k = m$ かつ $p, q$ 固定のとき $m$ を取り出すことができる。どうやって？ (WaniCTF DSA?)
Hard: IP 偽装を署名を用いて防ぐことはできるでしょうか？
:::

> **証明プロトコル**

> **Fiat-Shamir 変換**
> 対話証明プロトコルからハッシュ関数を用いて電子署名に変換する方法。
> - 署名
>   1. メッセージや疑似乱数 $r$ すべての公開値の情報これをチャレンジという $x$ を $e = H(x)$,。 $s = r - xe$
> - 検証
>   1. $x' := g^yp^{H(x)}$
> 検証者がランダムに選択するチャレンジの値
> $b := H(com)$

> **Schnorr Signature**
> 非対話型ゼロ知識証明な署名の一種。
>
> 1. 鍵生成 : 巡回群 $G$ 上で生成元 $g\in G$ と秘密鍵 $x\in\mathbb{N}$ を用いて公開鍵 $y = g^x$ を生成する。
> 2. 署名 : 疑似乱数 $k$ を生成し、署名したいメッセージ $M$ を用いて $e = H(g^k \| M), s = k - xe$ を計算して $(s, e)$ を署名値として公開する。
> 3. 検証 : $e' = H(g^sy^e \| M)$ を計算し、 $e = e'$ となれば署名が有効であると検証されたことになる。

チャレンジにすべての公開値を含めないと Frozen Heart プロトコルや実装による脆弱性。

- [Coordinated disclosure of vulnerabilities affecting Girault, Bulletproofs, and PlonK | Trail of Bits Blog](https://blog.trailofbits.com/2022/04/13/part-1-coordinated-disclosure-of-vulnerabilities-affecting-girault-bulletproofs-and-plonk/)

位置情報共有
Intel HEXL
> **BLS署名**
> 1. 鍵生成 : 0以上r未満の乱数sを一つ取り秘密鍵とします。公開鍵はsQです。
> 2. 署名 : メッセージmに対してそのハッシュ値H(m)をとり、秘密鍵s倍して署名s H(m)を作ります。
> 3. 検証 : メッセージmと署名σをもらった人は自分でハッシュ値H(m)を計算し公開鍵sQを使って
